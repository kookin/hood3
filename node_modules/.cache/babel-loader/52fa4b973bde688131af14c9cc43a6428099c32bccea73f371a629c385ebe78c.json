{"ast":null,"code":"import { RELAYER_DEFAULT_PROTOCOL as le, RELAYER_EVENTS as F, EXPIRER_EVENTS as pe, Store as U, Core as he } from \"@walletconnect/core\";\nimport { pino as de, getDefaultLoggerOptions as ge, generateChildLogger as me, getLoggerContext as ue } from \"@walletconnect/logger\";\nimport { IEngine as we, ISignClient as ye } from \"@walletconnect/types\";\nimport { TYPE_1 as Se, createDelayedPromise as T, engineEvent as p, getInternalError as c, calcExpiry as _, isValidObject as K, getRequiredNamespacesFromNamespaces as Ie, getSdkError as E, isSessionCompatible as _e, isBrowser as Ee, hashMessage as z, isExpired as P, isValidParams as S, isUndefined as x, isValidRelays as Re, isValidRequiredNamespaces as Ne, isValidNamespaces as Y, isConformingNamespaces as B, isValidString as D, isValidErrorReason as fe, isValidRelay as ve, isValidController as Pe, isValidNamespacesChainId as Q, isValidRequest as qe, isValidNamespacesRequest as Oe, isValidRequestExpiry as Ve, isValidResponse as Te, isValidEvent as xe, isValidNamespacesEvent as De, parseExpirerTarget as Ae, isValidId as Ce, getAppMetadata as Le } from \"@walletconnect/utils\";\nimport be, { EventEmitter as Ge } from \"events\";\nimport { THIRTY_DAYS as $e, SEVEN_DAYS as W, FIVE_MINUTES as u, ONE_DAY as q, THIRTY_SECONDS as Z } from \"@walletconnect/time\";\nimport { isJsonRpcResult as R, isJsonRpcError as N, formatJsonRpcRequest as Me, formatJsonRpcResult as Ue, formatJsonRpcError as Ke, isJsonRpcRequest as ze, isJsonRpcResponse as Ye } from \"@walletconnect/jsonrpc-utils\";\nconst j = \"wc\",\n  k = 2,\n  J = \"client\",\n  L = `${j}@${k}:${J}:`,\n  b = {\n    name: J,\n    logger: \"error\",\n    controller: !1,\n    relayUrl: \"wss://relay.walletconnect.com\"\n  },\n  je = {\n    session_proposal: \"session_proposal\",\n    session_update: \"session_update\",\n    session_extend: \"session_extend\",\n    session_ping: \"session_ping\",\n    session_delete: \"session_delete\",\n    session_expire: \"session_expire\",\n    session_request: \"session_request\",\n    session_request_sent: \"session_request_sent\",\n    session_event: \"session_event\",\n    proposal_expire: \"proposal_expire\"\n  },\n  ke = {\n    database: \":memory:\"\n  },\n  Je = {\n    created: \"history_created\",\n    updated: \"history_updated\",\n    deleted: \"history_deleted\",\n    sync: \"history_sync\"\n  },\n  Xe = \"history\",\n  He = \"0.3\",\n  ee = \"proposal\",\n  Fe = $e,\n  se = \"Proposal expired\",\n  te = \"session\",\n  A = W,\n  ie = \"engine\",\n  O = {\n    wc_sessionPropose: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1100\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1101\n      }\n    },\n    wc_sessionSettle: {\n      req: {\n        ttl: u,\n        prompt: !1,\n        tag: 1102\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1103\n      }\n    },\n    wc_sessionUpdate: {\n      req: {\n        ttl: q,\n        prompt: !1,\n        tag: 1104\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1105\n      }\n    },\n    wc_sessionExtend: {\n      req: {\n        ttl: q,\n        prompt: !1,\n        tag: 1106\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1107\n      }\n    },\n    wc_sessionRequest: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1108\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1109\n      }\n    },\n    wc_sessionEvent: {\n      req: {\n        ttl: u,\n        prompt: !0,\n        tag: 1110\n      },\n      res: {\n        ttl: u,\n        prompt: !1,\n        tag: 1111\n      }\n    },\n    wc_sessionDelete: {\n      req: {\n        ttl: q,\n        prompt: !1,\n        tag: 1112\n      },\n      res: {\n        ttl: q,\n        prompt: !1,\n        tag: 1113\n      }\n    },\n    wc_sessionPing: {\n      req: {\n        ttl: Z,\n        prompt: !1,\n        tag: 1114\n      },\n      res: {\n        ttl: Z,\n        prompt: !1,\n        tag: 1115\n      }\n    }\n  },\n  G = {\n    min: u,\n    max: W\n  },\n  re = \"request\",\n  ne = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\nvar Be = Object.defineProperty,\n  Qe = Object.defineProperties,\n  We = Object.getOwnPropertyDescriptors,\n  oe = Object.getOwnPropertySymbols,\n  Ze = Object.prototype.hasOwnProperty,\n  es = Object.prototype.propertyIsEnumerable,\n  ae = (d, r, e) => r in d ? Be(d, r, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : d[r] = e,\n  w = (d, r) => {\n    for (var e in r || (r = {})) Ze.call(r, e) && ae(d, e, r[e]);\n    if (oe) for (var e of oe(r)) es.call(r, e) && ae(d, e, r[e]);\n    return d;\n  },\n  X = (d, r) => Qe(d, We(r));\nclass ss extends we {\n  constructor(r) {\n    var _this;\n    (super(r), _this = this), this.name = ie, this.events = new be(), this.initialized = !1, this.ignoredPayloadTypes = [Se], this.init = async () => {\n      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.client.core.pairing.register({\n        methods: Object.keys(O)\n      }), this.initialized = !0);\n    }, this.connect = async e => {\n      this.isInitialized();\n      const s = X(w({}, e), {\n        requiredNamespaces: e.requiredNamespaces || {},\n        optionalNamespaces: e.optionalNamespaces || {}\n      });\n      await this.isValidConnect(s);\n      const {\n        pairingTopic: t,\n        requiredNamespaces: i,\n        optionalNamespaces: n,\n        sessionProperties: a,\n        relays: o\n      } = s;\n      let l = t,\n        h,\n        I = !1;\n      if (l && (I = this.client.core.pairing.pairings.get(l).active), !l || !I) {\n        const {\n          topic: v,\n          uri: y\n        } = await this.client.core.pairing.create();\n        l = v, h = y;\n      }\n      const g = await this.client.core.crypto.generateKeyPair(),\n        f = w({\n          requiredNamespaces: i,\n          optionalNamespaces: n,\n          relays: o ?? [{\n            protocol: le\n          }],\n          proposer: {\n            publicKey: g,\n            metadata: this.client.metadata\n          }\n        }, a && {\n          sessionProperties: a\n        }),\n        {\n          reject: m,\n          resolve: V,\n          done: M\n        } = T(u, se);\n      if (this.events.once(p(\"session_connect\"), async _ref => {\n        let {\n          error: v,\n          session: y\n        } = _ref;\n        if (v) m(v);else if (y) {\n          y.self.publicKey = g;\n          const H = X(w({}, y), {\n            requiredNamespaces: y.requiredNamespaces,\n            optionalNamespaces: y.optionalNamespaces\n          });\n          await this.client.session.set(y.topic, H), await this.setExpiry(y.topic, y.expiry), l && (await this.client.core.pairing.updateMetadata({\n            topic: l,\n            metadata: y.peer.metadata\n          })), V(H);\n        }\n      }), !l) {\n        const {\n          message: v\n        } = c(\"NO_MATCHING_KEY\", `connect() pairing topic: ${l}`);\n        throw new Error(v);\n      }\n      const C = await this.sendRequest(l, \"wc_sessionPropose\", f),\n        ce = _(u);\n      return await this.setProposal(C, w({\n        id: C,\n        expiry: ce\n      }, f)), {\n        uri: h,\n        approval: M\n      };\n    }, this.pair = async e => (this.isInitialized(), await this.client.core.pairing.pair(e)), this.approve = async e => {\n      this.isInitialized(), await this.isValidApprove(e);\n      const {\n          id: s,\n          relayProtocol: t,\n          namespaces: i,\n          sessionProperties: n\n        } = e,\n        a = this.client.proposal.get(s);\n      let {\n        pairingTopic: o,\n        proposer: l,\n        requiredNamespaces: h,\n        optionalNamespaces: I\n      } = a;\n      o = o || \"\", K(h) || (h = Ie(i, \"approve()\"));\n      const g = await this.client.core.crypto.generateKeyPair(),\n        f = l.publicKey,\n        m = await this.client.core.crypto.generateSharedKey(g, f);\n      o && s && (await this.client.core.pairing.updateMetadata({\n        topic: o,\n        metadata: l.metadata\n      }), await this.sendResult(s, o, {\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        responderPublicKey: g\n      }), await this.client.proposal.delete(s, E(\"USER_DISCONNECTED\")), await this.client.core.pairing.activate({\n        topic: o\n      }));\n      const V = w({\n        relay: {\n          protocol: t ?? \"irn\"\n        },\n        namespaces: i,\n        requiredNamespaces: h,\n        optionalNamespaces: I,\n        pairingTopic: o,\n        controller: {\n          publicKey: g,\n          metadata: this.client.metadata\n        },\n        expiry: _(A)\n      }, n && {\n        sessionProperties: n\n      });\n      await this.client.core.relayer.subscribe(m), await this.sendRequest(m, \"wc_sessionSettle\", V);\n      const M = X(w({}, V), {\n        topic: m,\n        pairingTopic: o,\n        acknowledged: !1,\n        self: V.controller,\n        peer: {\n          publicKey: l.publicKey,\n          metadata: l.metadata\n        },\n        controller: g\n      });\n      return await this.client.session.set(m, M), await this.setExpiry(m, _(A)), {\n        topic: m,\n        acknowledged: () => new Promise(C => setTimeout(() => C(this.client.session.get(m)), 500))\n      };\n    }, this.reject = async e => {\n      this.isInitialized(), await this.isValidReject(e);\n      const {\n          id: s,\n          reason: t\n        } = e,\n        {\n          pairingTopic: i\n        } = this.client.proposal.get(s);\n      i && (await this.sendError(s, i, t), await this.client.proposal.delete(s, E(\"USER_DISCONNECTED\")));\n    }, this.update = async e => {\n      this.isInitialized(), await this.isValidUpdate(e);\n      const {\n          topic: s,\n          namespaces: t\n        } = e,\n        i = await this.sendRequest(s, \"wc_sessionUpdate\", {\n          namespaces: t\n        }),\n        {\n          done: n,\n          resolve: a,\n          reject: o\n        } = T();\n      return this.events.once(p(\"session_update\", i), _ref2 => {\n        let {\n          error: l\n        } = _ref2;\n        l ? o(l) : a();\n      }), await this.client.session.update(s, {\n        namespaces: t\n      }), {\n        acknowledged: n\n      };\n    }, this.extend = async e => {\n      this.isInitialized(), await this.isValidExtend(e);\n      const {\n          topic: s\n        } = e,\n        t = await this.sendRequest(s, \"wc_sessionExtend\", {}),\n        {\n          done: i,\n          resolve: n,\n          reject: a\n        } = T();\n      return this.events.once(p(\"session_extend\", t), _ref3 => {\n        let {\n          error: o\n        } = _ref3;\n        o ? a(o) : n();\n      }), await this.setExpiry(s, _(A)), {\n        acknowledged: i\n      };\n    }, this.request = async e => {\n      this.isInitialized(), await this.isValidRequest(e);\n      const {\n          chainId: s,\n          request: t,\n          topic: i,\n          expiry: n\n        } = e,\n        a = await this.sendRequest(i, \"wc_sessionRequest\", {\n          request: t,\n          chainId: s\n        }, n),\n        {\n          done: o,\n          resolve: l,\n          reject: h\n        } = T(n);\n      return this.events.once(p(\"session_request\", a), _ref4 => {\n        let {\n          error: I,\n          result: g\n        } = _ref4;\n        I ? h(I) : l(g);\n      }), this.client.events.emit(\"session_request_sent\", {\n        topic: i,\n        request: t,\n        chainId: s,\n        id: a\n      }), await o();\n    }, this.respond = async e => {\n      this.isInitialized(), await this.isValidRespond(e);\n      const {\n          topic: s,\n          response: t\n        } = e,\n        {\n          id: i\n        } = t;\n      R(t) ? await this.sendResult(i, s, t.result) : N(t) && (await this.sendError(i, s, t.error)), this.deletePendingSessionRequest(e.response.id, {\n        message: \"fulfilled\",\n        code: 0\n      });\n    }, this.ping = async e => {\n      this.isInitialized(), await this.isValidPing(e);\n      const {\n        topic: s\n      } = e;\n      if (this.client.session.keys.includes(s)) {\n        const t = await this.sendRequest(s, \"wc_sessionPing\", {}),\n          {\n            done: i,\n            resolve: n,\n            reject: a\n          } = T();\n        this.events.once(p(\"session_ping\", t), _ref5 => {\n          let {\n            error: o\n          } = _ref5;\n          o ? a(o) : n();\n        }), await i();\n      } else this.client.core.pairing.pairings.keys.includes(s) && (await this.client.core.pairing.ping({\n        topic: s\n      }));\n    }, this.emit = async e => {\n      this.isInitialized(), await this.isValidEmit(e);\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.sendRequest(s, \"wc_sessionEvent\", {\n        event: t,\n        chainId: i\n      });\n    }, this.disconnect = async e => {\n      this.isInitialized(), await this.isValidDisconnect(e);\n      const {\n        topic: s\n      } = e;\n      this.client.session.keys.includes(s) ? (await this.sendRequest(s, \"wc_sessionDelete\", E(\"USER_DISCONNECTED\")), await this.deleteSession(s)) : await this.client.core.pairing.disconnect({\n        topic: s\n      });\n    }, this.find = e => (this.isInitialized(), this.client.session.getAll().filter(s => _e(s, e))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async e => {\n      try {\n        const s = this.client.core.pairing.pairings.get(e.pairingTopic),\n          t = this.client.core.pairing.pairings.getAll().filter(i => {\n            var n, a;\n            return ((n = i.peerMetadata) == null ? void 0 : n.url) && ((a = i.peerMetadata) == null ? void 0 : a.url) === e.self.metadata.url && i.topic !== s.topic;\n          });\n        if (t.length === 0) return;\n        this.client.logger.info(`Cleaning up ${t.length} duplicate pairing(s)`), await Promise.all(t.map(i => this.client.core.pairing.disconnect({\n          topic: i.topic\n        }))), this.client.logger.info(\"Duplicate pairings clean up finished\");\n      } catch (s) {\n        this.client.logger.error(s);\n      }\n    }, this.deleteSession = async (e, s) => {\n      const {\n        self: t\n      } = this.client.session.get(e);\n      await this.client.core.relayer.unsubscribe(e), await Promise.all([this.client.session.delete(e, E(\"USER_DISCONNECTED\")), this.client.core.crypto.deleteKeyPair(t.publicKey), this.client.core.crypto.deleteSymKey(e), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deleteProposal = async (e, s) => {\n      await Promise.all([this.client.proposal.delete(e, E(\"USER_DISCONNECTED\")), s ? Promise.resolve() : this.client.core.expirer.del(e)]);\n    }, this.deletePendingSessionRequest = async function (e, s) {\n      let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n      await Promise.all([_this.client.pendingRequest.delete(e, s), t ? Promise.resolve() : _this.client.core.expirer.del(e)]);\n    }, this.setExpiry = async (e, s) => {\n      this.client.session.keys.includes(e) && (await this.client.session.update(e, {\n        expiry: s\n      })), this.client.core.expirer.set(e, s);\n    }, this.setProposal = async (e, s) => {\n      await this.client.proposal.set(e, s), this.client.core.expirer.set(e, s.expiry);\n    }, this.setPendingSessionRequest = async e => {\n      const s = O.wc_sessionRequest.req.ttl,\n        {\n          id: t,\n          topic: i,\n          params: n\n        } = e;\n      await this.client.pendingRequest.set(t, {\n        id: t,\n        topic: i,\n        params: n\n      }), s && this.client.core.expirer.set(t, _(s));\n    }, this.sendRequest = async (e, s, t, i) => {\n      const n = Me(s, t);\n      if (Ee() && ne.includes(s)) {\n        const l = z(JSON.stringify(n));\n        await this.client.core.verify.register({\n          attestationId: l\n        });\n      }\n      const a = await this.client.core.crypto.encode(e, n),\n        o = O[s].req;\n      return i && (o.ttl = i), this.client.core.history.set(e, n), this.client.core.relayer.publish(e, a, o), n.id;\n    }, this.sendResult = async (e, s, t) => {\n      const i = Ue(e, t),\n        n = await this.client.core.crypto.encode(s, i),\n        a = await this.client.core.history.get(s, e),\n        o = O[a.request.method].res;\n      this.client.core.relayer.publish(s, n, o), await this.client.core.history.resolve(i);\n    }, this.sendError = async (e, s, t) => {\n      const i = Ke(e, t),\n        n = await this.client.core.crypto.encode(s, i),\n        a = await this.client.core.history.get(s, e),\n        o = O[a.request.method].res;\n      this.client.core.relayer.publish(s, n, o), await this.client.core.history.resolve(i);\n    }, this.cleanup = async () => {\n      const e = [],\n        s = [];\n      this.client.session.getAll().forEach(t => {\n        P(t.expiry) && e.push(t.topic);\n      }), this.client.proposal.getAll().forEach(t => {\n        P(t.expiry) && s.push(t.id);\n      }), await Promise.all([...e.map(t => this.deleteSession(t)), ...s.map(t => this.deleteProposal(t))]);\n    }, this.onRelayEventRequest = e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = t.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeRequest(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleRequest(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateRequest(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendRequest(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingRequest(s, t);\n        case \"wc_sessionDelete\":\n          return this.onSessionDeleteRequest(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequest(s, t);\n        case \"wc_sessionEvent\":\n          return this.onSessionEventRequest(s, t);\n        default:\n          return this.client.logger.info(`Unsupported request method ${i}`);\n      }\n    }, this.onRelayEventResponse = async e => {\n      const {\n          topic: s,\n          payload: t\n        } = e,\n        i = (await this.client.core.history.get(s, t.id)).request.method;\n      switch (i) {\n        case \"wc_sessionPropose\":\n          return this.onSessionProposeResponse(s, t);\n        case \"wc_sessionSettle\":\n          return this.onSessionSettleResponse(s, t);\n        case \"wc_sessionUpdate\":\n          return this.onSessionUpdateResponse(s, t);\n        case \"wc_sessionExtend\":\n          return this.onSessionExtendResponse(s, t);\n        case \"wc_sessionPing\":\n          return this.onSessionPingResponse(s, t);\n        case \"wc_sessionRequest\":\n          return this.onSessionRequestResponse(s, t);\n        default:\n          return this.client.logger.info(`Unsupported response method ${i}`);\n      }\n    }, this.onSessionProposeRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidConnect(w({}, s.params));\n        const n = _(u),\n          a = w({\n            id: i,\n            pairingTopic: e,\n            expiry: n\n          }, t);\n        await this.setProposal(i, a);\n        const o = z(JSON.stringify(s)),\n          l = await this.getVerifyContext(o, a.proposer.metadata);\n        this.client.events.emit(\"session_proposal\", {\n          id: i,\n          params: a,\n          verifyContext: l\n        });\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionProposeResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      if (R(s)) {\n        const {\n          result: i\n        } = s;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          result: i\n        });\n        const n = this.client.proposal.get(t);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          proposal: n\n        });\n        const a = n.proposer.publicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          selfPublicKey: a\n        });\n        const o = i.responderPublicKey;\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          peerPublicKey: o\n        });\n        const l = await this.client.core.crypto.generateSharedKey(a, o);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          sessionTopic: l\n        });\n        const h = await this.client.core.relayer.subscribe(l);\n        this.client.logger.trace({\n          type: \"method\",\n          method: \"onSessionProposeResponse\",\n          subscriptionId: h\n        }), await this.client.core.pairing.activate({\n          topic: e\n        });\n      } else N(s) && (await this.client.proposal.delete(t, E(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_connect\"), {\n        error: s.error\n      }));\n    }, this.onSessionSettleRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidSessionSettleRequest(i);\n        const {\n            relay: n,\n            controller: a,\n            expiry: o,\n            namespaces: l,\n            requiredNamespaces: h,\n            optionalNamespaces: I,\n            sessionProperties: g,\n            pairingTopic: f\n          } = s.params,\n          m = w({\n            topic: e,\n            relay: n,\n            expiry: o,\n            namespaces: l,\n            acknowledged: !0,\n            pairingTopic: f,\n            requiredNamespaces: h,\n            optionalNamespaces: I,\n            controller: a.publicKey,\n            self: {\n              publicKey: \"\",\n              metadata: this.client.metadata\n            },\n            peer: {\n              publicKey: a.publicKey,\n              metadata: a.metadata\n            }\n          }, g && {\n            sessionProperties: g\n          });\n        await this.sendResult(s.id, e, !0), this.events.emit(p(\"session_connect\"), {\n          session: m\n        }), this.cleanupDuplicatePairings(m);\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionSettleResponse = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? (await this.client.session.update(e, {\n        acknowledged: !0\n      }), this.events.emit(p(\"session_approve\", t), {})) : N(s) && (await this.client.session.delete(e, E(\"USER_DISCONNECTED\")), this.events.emit(p(\"session_approve\", t), {\n        error: s.error\n      }));\n    }, this.onSessionUpdateRequest = async (e, s) => {\n      const {\n        params: t,\n        id: i\n      } = s;\n      try {\n        this.isValidUpdate(w({\n          topic: e\n        }, t)), await this.client.session.update(e, {\n          namespaces: t.namespaces\n        }), await this.sendResult(i, e, !0), this.client.events.emit(\"session_update\", {\n          id: i,\n          topic: e,\n          params: t\n        });\n      } catch (n) {\n        await this.sendError(i, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionUpdateResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? this.events.emit(p(\"session_update\", t), {}) : N(s) && this.events.emit(p(\"session_update\", t), {\n        error: s.error\n      });\n    }, this.onSessionExtendRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidExtend({\n          topic: e\n        }), await this.setExpiry(e, _(A)), await this.sendResult(t, e, !0), this.client.events.emit(\"session_extend\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionExtendResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? this.events.emit(p(\"session_extend\", t), {}) : N(s) && this.events.emit(p(\"session_extend\", t), {\n        error: s.error\n      });\n    }, this.onSessionPingRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidPing({\n          topic: e\n        }), await this.sendResult(t, e, !0), this.client.events.emit(\"session_ping\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionPingResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      setTimeout(() => {\n        R(s) ? this.events.emit(p(\"session_ping\", t), {}) : N(s) && this.events.emit(p(\"session_ping\", t), {\n          error: s.error\n        });\n      }, 500);\n    }, this.onSessionDeleteRequest = async (e, s) => {\n      const {\n        id: t\n      } = s;\n      try {\n        this.isValidDisconnect({\n          topic: e,\n          reason: s.params\n        }), await Promise.all([new Promise(i => {\n          this.client.core.relayer.once(F.publish, async () => {\n            i(await this.deleteSession(e));\n          });\n        }), this.sendResult(t, e, !0)]), this.client.events.emit(\"session_delete\", {\n          id: t,\n          topic: e\n        });\n      } catch (i) {\n        await this.sendError(t, e, i), this.client.logger.error(i);\n      }\n    }, this.onSessionRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidRequest(w({\n          topic: e\n        }, i)), await this.setPendingSessionRequest({\n          id: t,\n          topic: e,\n          params: i\n        });\n        const n = z(JSON.stringify(s)),\n          a = this.client.session.get(e),\n          o = await this.getVerifyContext(n, a.peer.metadata);\n        this.client.events.emit(\"session_request\", {\n          id: t,\n          topic: e,\n          params: i,\n          verifyContext: o\n        });\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.onSessionRequestResponse = (e, s) => {\n      const {\n        id: t\n      } = s;\n      R(s) ? this.events.emit(p(\"session_request\", t), {\n        result: s.result\n      }) : N(s) && this.events.emit(p(\"session_request\", t), {\n        error: s.error\n      });\n    }, this.onSessionEventRequest = async (e, s) => {\n      const {\n        id: t,\n        params: i\n      } = s;\n      try {\n        this.isValidEmit(w({\n          topic: e\n        }, i)), this.client.events.emit(\"session_event\", {\n          id: t,\n          topic: e,\n          params: i\n        });\n      } catch (n) {\n        await this.sendError(t, e, n), this.client.logger.error(n);\n      }\n    }, this.isValidConnect = async e => {\n      if (!S(e)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `connect() params: ${JSON.stringify(e)}`);\n        throw new Error(o);\n      }\n      const {\n        pairingTopic: s,\n        requiredNamespaces: t,\n        optionalNamespaces: i,\n        sessionProperties: n,\n        relays: a\n      } = e;\n      if (x(s) || (await this.isValidPairingTopic(s)), !Re(a, !0)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `connect() relays: ${a}`);\n        throw new Error(o);\n      }\n      !x(t) && K(t) !== 0 && this.validateNamespaces(t, \"requiredNamespaces\"), !x(i) && K(i) !== 0 && this.validateNamespaces(i, \"optionalNamespaces\"), x(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.validateNamespaces = (e, s) => {\n      const t = Ne(e, \"connect()\", s);\n      if (t) throw new Error(t.message);\n    }, this.isValidApprove = async e => {\n      if (!S(e)) throw new Error(c(\"MISSING_OR_INVALID\", `approve() params: ${e}`).message);\n      const {\n        id: s,\n        namespaces: t,\n        relayProtocol: i,\n        sessionProperties: n\n      } = e;\n      await this.isValidProposalId(s);\n      const a = this.client.proposal.get(s),\n        o = Y(t, \"approve()\");\n      if (o) throw new Error(o.message);\n      const l = B(a.requiredNamespaces, t, \"approve()\");\n      if (l) throw new Error(l.message);\n      if (!D(i, !0)) {\n        const {\n          message: h\n        } = c(\"MISSING_OR_INVALID\", `approve() relayProtocol: ${i}`);\n        throw new Error(h);\n      }\n      x(n) || this.validateSessionProps(n, \"sessionProperties\");\n    }, this.isValidReject = async e => {\n      if (!S(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        id: s,\n        reason: t\n      } = e;\n      if (await this.isValidProposalId(s), !fe(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `reject() reason: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidSessionSettleRequest = e => {\n      if (!S(e)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", `onSessionSettleRequest() params: ${e}`);\n        throw new Error(l);\n      }\n      const {\n        relay: s,\n        controller: t,\n        namespaces: i,\n        expiry: n\n      } = e;\n      if (!ve(s)) {\n        const {\n          message: l\n        } = c(\"MISSING_OR_INVALID\", \"onSessionSettleRequest() relay protocol should be a string\");\n        throw new Error(l);\n      }\n      const a = Pe(t, \"onSessionSettleRequest()\");\n      if (a) throw new Error(a.message);\n      const o = Y(i, \"onSessionSettleRequest()\");\n      if (o) throw new Error(o.message);\n      if (P(n)) {\n        const {\n          message: l\n        } = c(\"EXPIRED\", \"onSessionSettleRequest()\");\n        throw new Error(l);\n      }\n    }, this.isValidUpdate = async e => {\n      if (!S(e)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `update() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: s,\n        namespaces: t\n      } = e;\n      await this.isValidSessionTopic(s);\n      const i = this.client.session.get(s),\n        n = Y(t, \"update()\");\n      if (n) throw new Error(n.message);\n      const a = B(i.requiredNamespaces, t, \"update()\");\n      if (a) throw new Error(a.message);\n    }, this.isValidExtend = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `extend() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionTopic(s);\n    }, this.isValidRequest = async e => {\n      if (!S(e)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `request() params: ${e}`);\n        throw new Error(o);\n      }\n      const {\n        topic: s,\n        request: t,\n        chainId: i,\n        expiry: n\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: a\n      } = this.client.session.get(s);\n      if (!Q(a, i)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `request() chainId: ${i}`);\n        throw new Error(o);\n      }\n      if (!qe(t)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `request() ${JSON.stringify(t)}`);\n        throw new Error(o);\n      }\n      if (!Oe(a, i, t.method)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `request() method: ${t.method}`);\n        throw new Error(o);\n      }\n      if (n && !Ve(n, G)) {\n        const {\n          message: o\n        } = c(\"MISSING_OR_INVALID\", `request() expiry: ${n}. Expiry must be a number (in seconds) between ${G.min} and ${G.max}`);\n        throw new Error(o);\n      }\n    }, this.isValidRespond = async e => {\n      if (!S(e)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() params: ${e}`);\n        throw new Error(i);\n      }\n      const {\n        topic: s,\n        response: t\n      } = e;\n      if (await this.isValidSessionTopic(s), !Te(t)) {\n        const {\n          message: i\n        } = c(\"MISSING_OR_INVALID\", `respond() response: ${JSON.stringify(t)}`);\n        throw new Error(i);\n      }\n    }, this.isValidPing = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `ping() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.isValidEmit = async e => {\n      if (!S(e)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() params: ${e}`);\n        throw new Error(a);\n      }\n      const {\n        topic: s,\n        event: t,\n        chainId: i\n      } = e;\n      await this.isValidSessionTopic(s);\n      const {\n        namespaces: n\n      } = this.client.session.get(s);\n      if (!Q(n, i)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() chainId: ${i}`);\n        throw new Error(a);\n      }\n      if (!xe(t)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n      if (!De(n, i, t.name)) {\n        const {\n          message: a\n        } = c(\"MISSING_OR_INVALID\", `emit() event: ${JSON.stringify(t)}`);\n        throw new Error(a);\n      }\n    }, this.isValidDisconnect = async e => {\n      if (!S(e)) {\n        const {\n          message: t\n        } = c(\"MISSING_OR_INVALID\", `disconnect() params: ${e}`);\n        throw new Error(t);\n      }\n      const {\n        topic: s\n      } = e;\n      await this.isValidSessionOrPairingTopic(s);\n    }, this.getVerifyContext = async (e, s) => {\n      const t = {\n        verified: {\n          verifyUrl: s.verifyUrl || \"\",\n          validation: \"UNKNOWN\",\n          origin: s.url || \"\"\n        }\n      };\n      try {\n        const i = await this.client.core.verify.resolve({\n          attestationId: e,\n          verifyUrl: s.verifyUrl\n        });\n        i && (t.verified.origin = i, t.verified.validation = i === s.url ? \"VALID\" : \"INVALID\");\n      } catch (i) {\n        this.client.logger.error(i);\n      }\n      return this.client.logger.info(`Verify context: ${JSON.stringify(t)}`), t;\n    }, this.validateSessionProps = (e, s) => {\n      Object.values(e).forEach(t => {\n        if (!D(t, !1)) {\n          const {\n            message: i\n          } = c(\"MISSING_OR_INVALID\", `${s} must be in Record<string, string> format. Received: ${JSON.stringify(t)}`);\n          throw new Error(i);\n        }\n      });\n    };\n  }\n  isInitialized() {\n    if (!this.initialized) {\n      const {\n        message: r\n      } = c(\"NOT_INITIALIZED\", this.name);\n      throw new Error(r);\n    }\n  }\n  registerRelayerEvents() {\n    this.client.core.relayer.on(F.message, async r => {\n      const {\n        topic: e,\n        message: s\n      } = r;\n      if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s))) return;\n      const t = await this.client.core.crypto.decode(e, s);\n      ze(t) ? (this.client.core.history.set(e, t), this.onRelayEventRequest({\n        topic: e,\n        payload: t\n      })) : Ye(t) && (await this.client.core.history.resolve(t), this.onRelayEventResponse({\n        topic: e,\n        payload: t\n      }));\n    });\n  }\n  registerExpirerEvents() {\n    this.client.core.expirer.on(pe.expired, async r => {\n      const {\n        topic: e,\n        id: s\n      } = Ae(r.target);\n      if (s && this.client.pendingRequest.keys.includes(s)) return await this.deletePendingSessionRequest(s, c(\"EXPIRED\"), !0);\n      e ? this.client.session.keys.includes(e) && (await this.deleteSession(e, !0), this.client.events.emit(\"session_expire\", {\n        topic: e\n      })) : s && (await this.deleteProposal(s, !0), this.client.events.emit(\"proposal_expire\", {\n        id: s\n      }));\n    });\n  }\n  isValidPairingTopic(r) {\n    if (!D(r, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(r)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (P(this.client.core.pairing.pairings.get(r).expiry)) {\n      const {\n        message: e\n      } = c(\"EXPIRED\", `pairing topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionTopic(r) {\n    if (!D(r, !1)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.session.keys.includes(r)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session topic doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (P(this.client.session.get(r).expiry)) {\n      await this.deleteSession(r);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `session topic: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidSessionOrPairingTopic(r) {\n    if (this.client.session.keys.includes(r)) await this.isValidSessionTopic(r);else if (this.client.core.pairing.pairings.keys.includes(r)) this.isValidPairingTopic(r);else if (D(r, !1)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `session or pairing topic doesn't exist: ${r}`);\n      throw new Error(e);\n    } else {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `session or pairing topic should be a string: ${r}`);\n      throw new Error(e);\n    }\n  }\n  async isValidProposalId(r) {\n    if (!Ce(r)) {\n      const {\n        message: e\n      } = c(\"MISSING_OR_INVALID\", `proposal id should be a number: ${r}`);\n      throw new Error(e);\n    }\n    if (!this.client.proposal.keys.includes(r)) {\n      const {\n        message: e\n      } = c(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${r}`);\n      throw new Error(e);\n    }\n    if (P(this.client.proposal.get(r).expiry)) {\n      await this.deleteProposal(r);\n      const {\n        message: e\n      } = c(\"EXPIRED\", `proposal id: ${r}`);\n      throw new Error(e);\n    }\n  }\n}\nclass ts extends U {\n  constructor(r, e) {\n    super(r, e, ee, L), this.core = r, this.logger = e;\n  }\n}\nclass is extends U {\n  constructor(r, e) {\n    super(r, e, te, L), this.core = r, this.logger = e;\n  }\n}\nclass rs extends U {\n  constructor(r, e) {\n    super(r, e, re, L, s => s.id), this.core = r, this.logger = e;\n  }\n}\nclass $ extends ye {\n  constructor(r) {\n    super(r), this.protocol = j, this.version = k, this.name = b.name, this.events = new Ge(), this.on = (s, t) => this.events.on(s, t), this.once = (s, t) => this.events.once(s, t), this.off = (s, t) => this.events.off(s, t), this.removeListener = (s, t) => this.events.removeListener(s, t), this.removeAllListeners = s => this.events.removeAllListeners(s), this.connect = async s => {\n      try {\n        return await this.engine.connect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.pair = async s => {\n      try {\n        return await this.engine.pair(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.approve = async s => {\n      try {\n        return await this.engine.approve(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.reject = async s => {\n      try {\n        return await this.engine.reject(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.update = async s => {\n      try {\n        return await this.engine.update(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.extend = async s => {\n      try {\n        return await this.engine.extend(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.request = async s => {\n      try {\n        return await this.engine.request(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.respond = async s => {\n      try {\n        return await this.engine.respond(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.ping = async s => {\n      try {\n        return await this.engine.ping(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.emit = async s => {\n      try {\n        return await this.engine.emit(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.disconnect = async s => {\n      try {\n        return await this.engine.disconnect(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.find = s => {\n      try {\n        return this.engine.find(s);\n      } catch (t) {\n        throw this.logger.error(t.message), t;\n      }\n    }, this.getPendingSessionRequests = () => {\n      try {\n        return this.engine.getPendingSessionRequests();\n      } catch (s) {\n        throw this.logger.error(s.message), s;\n      }\n    }, this.name = r?.name || b.name, this.metadata = r?.metadata || Le();\n    const e = typeof r?.logger < \"u\" && typeof r?.logger != \"string\" ? r.logger : de(ge({\n      level: r?.logger || b.logger\n    }));\n    this.core = r?.core || new he(r), this.logger = me(e, this.name), this.session = new is(this.core, this.logger), this.proposal = new ts(this.core, this.logger), this.pendingRequest = new rs(this.core, this.logger), this.engine = new ss(this);\n  }\n  static async init(r) {\n    const e = new $(r);\n    return await e.initialize(), e;\n  }\n  get context() {\n    return ue(this.logger);\n  }\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\");\n    try {\n      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({\n        verifyUrl: this.metadata.verifyUrl\n      }), this.logger.info(\"SignClient Initialization Success\");\n    } catch (r) {\n      throw this.logger.info(\"SignClient Initialization Failure\"), this.logger.error(r.message), r;\n    }\n  }\n}\nconst ns = $;\nexport { ie as ENGINE_CONTEXT, O as ENGINE_RPC_OPTS, Xe as HISTORY_CONTEXT, Je as HISTORY_EVENTS, He as HISTORY_STORAGE_VERSION, ne as METHODS_TO_VERIFY, ee as PROPOSAL_CONTEXT, Fe as PROPOSAL_EXPIRY, se as PROPOSAL_EXPIRY_MESSAGE, re as REQUEST_CONTEXT, te as SESSION_CONTEXT, A as SESSION_EXPIRY, G as SESSION_REQUEST_EXPIRY_BOUNDARIES, J as SIGN_CLIENT_CONTEXT, b as SIGN_CLIENT_DEFAULT, je as SIGN_CLIENT_EVENTS, j as SIGN_CLIENT_PROTOCOL, ke as SIGN_CLIENT_STORAGE_OPTIONS, L as SIGN_CLIENT_STORAGE_PREFIX, k as SIGN_CLIENT_VERSION, ns as SignClient, $ as default };","map":{"version":3,"names":[],"sources":["/hood3/node_modules/@walletconnect/sign-client/src/constants/client.ts","/hood3/node_modules/@walletconnect/sign-client/src/constants/history.ts","/hood3/node_modules/@walletconnect/sign-client/src/constants/proposal.ts","/hood3/node_modules/@walletconnect/sign-client/src/constants/session.ts","/hood3/node_modules/@walletconnect/sign-client/src/constants/engine.ts","/hood3/node_modules/@walletconnect/sign-client/src/constants/pendingRequest.ts","/hood3/node_modules/@walletconnect/sign-client/src/constants/verify.ts","/hood3/node_modules/@walletconnect/sign-client/src/controllers/engine.ts","/hood3/node_modules/@walletconnect/sign-client/src/controllers/proposal.ts","/hood3/node_modules/@walletconnect/sign-client/src/controllers/session.ts","/hood3/node_modules/@walletconnect/sign-client/src/controllers/pendingRequest.ts","/hood3/node_modules/@walletconnect/sign-client/src/client.ts","/hood3/node_modules/@walletconnect/sign-client/src/index.ts"],"sourcesContent":["import { SignClientTypes } from \"@walletconnect/types\";\n\nexport const SIGN_CLIENT_PROTOCOL = \"wc\";\nexport const SIGN_CLIENT_VERSION = 2;\nexport const SIGN_CLIENT_CONTEXT = \"client\";\n\nexport const SIGN_CLIENT_STORAGE_PREFIX = `${SIGN_CLIENT_PROTOCOL}@${SIGN_CLIENT_VERSION}:${SIGN_CLIENT_CONTEXT}:`;\n\nexport const SIGN_CLIENT_DEFAULT = {\n  name: SIGN_CLIENT_CONTEXT,\n  logger: \"error\",\n  controller: false,\n  relayUrl: \"wss://relay.walletconnect.com\",\n};\n\nexport const SIGN_CLIENT_EVENTS: Record<SignClientTypes.Event, SignClientTypes.Event> = {\n  session_proposal: \"session_proposal\",\n  session_update: \"session_update\",\n  session_extend: \"session_extend\",\n  session_ping: \"session_ping\",\n  session_delete: \"session_delete\",\n  session_expire: \"session_expire\",\n  session_request: \"session_request\",\n  session_request_sent: \"session_request_sent\",\n  session_event: \"session_event\",\n  proposal_expire: \"proposal_expire\",\n};\n\nexport const SIGN_CLIENT_STORAGE_OPTIONS = {\n  database: \":memory:\",\n};\n","export const HISTORY_EVENTS = {\n  created: \"history_created\",\n  updated: \"history_updated\",\n  deleted: \"history_deleted\",\n  sync: \"history_sync\",\n};\n\nexport const HISTORY_CONTEXT = \"history\";\n\nexport const HISTORY_STORAGE_VERSION = \"0.3\";\n","import { THIRTY_DAYS } from \"@walletconnect/time\";\n\nexport const PROPOSAL_CONTEXT = \"proposal\";\n\nexport const PROPOSAL_EXPIRY = THIRTY_DAYS;\n\nexport const PROPOSAL_EXPIRY_MESSAGE = \"Proposal expired\";\n","import { SEVEN_DAYS } from \"@walletconnect/time\";\n\nexport const SESSION_CONTEXT = \"session\";\n\nexport const SESSION_EXPIRY = SEVEN_DAYS;\n","import { FIVE_MINUTES, ONE_DAY, SEVEN_DAYS, THIRTY_SECONDS } from \"@walletconnect/time\";\nimport { EngineTypes } from \"@walletconnect/types\";\n\nexport const ENGINE_CONTEXT = \"engine\";\n\nexport const ENGINE_RPC_OPTS: EngineTypes.RpcOptsMap = {\n  wc_sessionPropose: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1100,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1101,\n    },\n  },\n  wc_sessionSettle: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1102,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1103,\n    },\n  },\n  wc_sessionUpdate: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1104,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1105,\n    },\n  },\n  wc_sessionExtend: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1106,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1107,\n    },\n  },\n  wc_sessionRequest: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1108,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1109,\n    },\n  },\n  wc_sessionEvent: {\n    req: {\n      ttl: FIVE_MINUTES,\n      prompt: true,\n      tag: 1110,\n    },\n    res: {\n      ttl: FIVE_MINUTES,\n      prompt: false,\n      tag: 1111,\n    },\n  },\n\n  wc_sessionDelete: {\n    req: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1112,\n    },\n    res: {\n      ttl: ONE_DAY,\n      prompt: false,\n      tag: 1113,\n    },\n  },\n  wc_sessionPing: {\n    req: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1114,\n    },\n    res: {\n      ttl: THIRTY_SECONDS,\n      prompt: false,\n      tag: 1115,\n    },\n  },\n};\n\nexport const SESSION_REQUEST_EXPIRY_BOUNDARIES = {\n  min: FIVE_MINUTES,\n  max: SEVEN_DAYS,\n};\n","export const REQUEST_CONTEXT = \"request\";\n","export const METHODS_TO_VERIFY = [\"wc_sessionPropose\", \"wc_sessionRequest\", \"wc_authRequest\"];\n","/* eslint-disable no-console */\nimport { EXPIRER_EVENTS, RELAYER_DEFAULT_PROTOCOL, RELAYER_EVENTS } from \"@walletconnect/core\";\n\nimport {\n  formatJsonRpcError,\n  formatJsonRpcRequest,\n  formatJsonRpcResult,\n  isJsonRpcError,\n  isJsonRpcRequest,\n  isJsonRpcResponse,\n  isJsonRpcResult,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { FIVE_MINUTES } from \"@walletconnect/time\";\nimport {\n  EnginePrivate,\n  EngineTypes,\n  ExpirerTypes,\n  IEngine,\n  IEngineEvents,\n  JsonRpcTypes,\n  PendingRequestTypes,\n  Verify,\n  CoreTypes,\n  ProposalTypes,\n  RelayerTypes,\n  SessionTypes,\n} from \"@walletconnect/types\";\nimport {\n  calcExpiry,\n  createDelayedPromise,\n  engineEvent,\n  getInternalError,\n  getRequiredNamespacesFromNamespaces,\n  getSdkError,\n  isConformingNamespaces,\n  isExpired,\n  isSessionCompatible,\n  isUndefined,\n  isValidController,\n  isValidErrorReason,\n  isValidEvent,\n  isValidId,\n  isValidNamespaces,\n  isValidNamespacesChainId,\n  isValidNamespacesEvent,\n  isValidNamespacesRequest,\n  isValidObject,\n  isValidParams,\n  isValidRelay,\n  isValidRelays,\n  isValidRequest,\n  isValidRequestExpiry,\n  hashMessage,\n  isBrowser,\n  isValidRequiredNamespaces,\n  isValidResponse,\n  isValidString,\n  parseExpirerTarget,\n  TYPE_1,\n} from \"@walletconnect/utils\";\nimport EventEmmiter from \"events\";\nimport {\n  ENGINE_CONTEXT,\n  ENGINE_RPC_OPTS,\n  PROPOSAL_EXPIRY_MESSAGE,\n  SESSION_EXPIRY,\n  SESSION_REQUEST_EXPIRY_BOUNDARIES,\n  METHODS_TO_VERIFY,\n} from \"../constants\";\n\nexport class Engine extends IEngine {\n  public name = ENGINE_CONTEXT;\n\n  private events: IEngineEvents = new EventEmmiter();\n  private initialized = false;\n  private ignoredPayloadTypes = [TYPE_1];\n\n  constructor(client: IEngine[\"client\"]) {\n    super(client);\n  }\n\n  public init: IEngine[\"init\"] = async () => {\n    if (!this.initialized) {\n      await this.cleanup();\n      this.registerRelayerEvents();\n      this.registerExpirerEvents();\n      this.client.core.pairing.register({ methods: Object.keys(ENGINE_RPC_OPTS) });\n      this.initialized = true;\n    }\n  };\n\n  // ---------- Public ------------------------------------------------ //\n\n  public connect: IEngine[\"connect\"] = async (params) => {\n    this.isInitialized();\n    const connectParams = {\n      ...params,\n      requiredNamespaces: params.requiredNamespaces || {},\n      optionalNamespaces: params.optionalNamespaces || {},\n    };\n    await this.isValidConnect(connectParams);\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      connectParams;\n    let topic = pairingTopic;\n    let uri: string | undefined;\n    let active = false;\n\n    if (topic) {\n      const pairing = this.client.core.pairing.pairings.get(topic);\n      active = pairing.active;\n    }\n\n    if (!topic || !active) {\n      const { topic: newTopic, uri: newUri } = await this.client.core.pairing.create();\n      topic = newTopic;\n      uri = newUri;\n    }\n\n    const publicKey = await this.client.core.crypto.generateKeyPair();\n\n    const proposal = {\n      requiredNamespaces,\n      optionalNamespaces,\n      relays: relays ?? [{ protocol: RELAYER_DEFAULT_PROTOCOL }],\n      proposer: {\n        publicKey,\n        metadata: this.client.metadata,\n      },\n      ...(sessionProperties && { sessionProperties }),\n    };\n    const {\n      reject,\n      resolve,\n      done: approval,\n    } = createDelayedPromise<SessionTypes.Struct>(FIVE_MINUTES, PROPOSAL_EXPIRY_MESSAGE);\n    this.events.once<\"session_connect\">(\n      engineEvent(\"session_connect\"),\n      async ({ error, session }) => {\n        if (error) reject(error);\n        else if (session) {\n          session.self.publicKey = publicKey;\n          const completeSession = {\n            ...session,\n            requiredNamespaces: session.requiredNamespaces,\n            optionalNamespaces: session.optionalNamespaces,\n          };\n          await this.client.session.set(session.topic, completeSession);\n          await this.setExpiry(session.topic, session.expiry);\n          if (topic) {\n            await this.client.core.pairing.updateMetadata({\n              topic,\n              metadata: session.peer.metadata,\n            });\n          }\n          resolve(completeSession);\n        }\n      },\n    );\n\n    if (!topic) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `connect() pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n\n    const id = await this.sendRequest(topic, \"wc_sessionPropose\", proposal);\n\n    const expiry = calcExpiry(FIVE_MINUTES);\n    await this.setProposal(id, { id, expiry, ...proposal });\n    return { uri, approval };\n  };\n\n  public pair: IEngine[\"pair\"] = async (params) => {\n    this.isInitialized();\n    return await this.client.core.pairing.pair(params);\n  };\n\n  public approve: IEngine[\"approve\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidApprove(params);\n    const { id, relayProtocol, namespaces, sessionProperties } = params;\n    const proposal = this.client.proposal.get(id);\n    let { pairingTopic, proposer, requiredNamespaces, optionalNamespaces } = proposal;\n    pairingTopic = pairingTopic || \"\";\n    if (!isValidObject(requiredNamespaces)) {\n      requiredNamespaces = getRequiredNamespacesFromNamespaces(namespaces, \"approve()\");\n    }\n\n    const selfPublicKey = await this.client.core.crypto.generateKeyPair();\n    const peerPublicKey = proposer.publicKey;\n    const sessionTopic = await this.client.core.crypto.generateSharedKey(\n      selfPublicKey,\n      peerPublicKey,\n    );\n\n    if (pairingTopic && id) {\n      await this.client.core.pairing.updateMetadata({\n        topic: pairingTopic,\n        metadata: proposer.metadata,\n      });\n      await this.sendResult<\"wc_sessionPropose\">(id, pairingTopic, {\n        relay: {\n          protocol: relayProtocol ?? \"irn\",\n        },\n        responderPublicKey: selfPublicKey,\n      });\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      await this.client.core.pairing.activate({ topic: pairingTopic });\n    }\n\n    const sessionSettle = {\n      relay: { protocol: relayProtocol ?? \"irn\" },\n      namespaces,\n      requiredNamespaces,\n      optionalNamespaces,\n      pairingTopic,\n      controller: { publicKey: selfPublicKey, metadata: this.client.metadata },\n      expiry: calcExpiry(SESSION_EXPIRY),\n      ...(sessionProperties && { sessionProperties }),\n    };\n    await this.client.core.relayer.subscribe(sessionTopic);\n    await this.sendRequest(sessionTopic, \"wc_sessionSettle\", sessionSettle);\n    const session = {\n      ...sessionSettle,\n      topic: sessionTopic,\n      pairingTopic,\n      acknowledged: false,\n      self: sessionSettle.controller,\n      peer: {\n        publicKey: proposer.publicKey,\n        metadata: proposer.metadata,\n      },\n      controller: selfPublicKey,\n    };\n    await this.client.session.set(sessionTopic, session);\n    await this.setExpiry(sessionTopic, calcExpiry(SESSION_EXPIRY));\n    return {\n      topic: sessionTopic,\n      acknowledged: () =>\n        new Promise((resolve) =>\n          setTimeout(() => resolve(this.client.session.get(sessionTopic)), 5_00),\n        ), // artificial delay to allow for the session to be processed by the peer\n    };\n  };\n\n  public reject: IEngine[\"reject\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidReject(params);\n    const { id, reason } = params;\n    const { pairingTopic } = this.client.proposal.get(id);\n    if (pairingTopic) {\n      await this.sendError(id, pairingTopic, reason);\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n    }\n  };\n\n  public update: IEngine[\"update\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidUpdate(params);\n    const { topic, namespaces } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionUpdate\", { namespaces });\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_update\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.client.session.update(topic, { namespaces });\n\n    return { acknowledged };\n  };\n\n  public extend: IEngine[\"extend\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidExtend(params);\n    const { topic } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionExtend\", {});\n    const { done: acknowledged, resolve, reject } = createDelayedPromise<void>();\n    this.events.once(engineEvent(\"session_extend\", id), ({ error }) => {\n      if (error) reject(error);\n      else resolve();\n    });\n    await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n\n    return { acknowledged };\n  };\n\n  public request: IEngine[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    this.isInitialized();\n    await this.isValidRequest(params);\n    const { chainId, request, topic, expiry } = params;\n    const id = await this.sendRequest(topic, \"wc_sessionRequest\", { request, chainId }, expiry);\n    const { done, resolve, reject } = createDelayedPromise<T>(expiry);\n    this.events.once<\"session_request\">(engineEvent(\"session_request\", id), ({ error, result }) => {\n      if (error) reject(error);\n      else resolve(result);\n    });\n    this.client.events.emit(\"session_request_sent\", { topic, request, chainId, id });\n    return await done();\n  };\n\n  public respond: IEngine[\"respond\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidRespond(params);\n    const { topic, response } = params;\n    const { id } = response;\n    if (isJsonRpcResult(response)) {\n      await this.sendResult(id, topic, response.result);\n    } else if (isJsonRpcError(response)) {\n      await this.sendError(id, topic, response.error);\n    }\n    this.deletePendingSessionRequest(params.response.id, { message: \"fulfilled\", code: 0 });\n  };\n\n  public ping: IEngine[\"ping\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidPing(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      const id = await this.sendRequest(topic, \"wc_sessionPing\", {});\n      const { done, resolve, reject } = createDelayedPromise<void>();\n      this.events.once(engineEvent(\"session_ping\", id), ({ error }) => {\n        if (error) reject(error);\n        else resolve();\n      });\n      await done();\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      await this.client.core.pairing.ping({ topic });\n    }\n  };\n\n  public emit: IEngine[\"emit\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidEmit(params);\n    const { topic, event, chainId } = params;\n    await this.sendRequest(topic, \"wc_sessionEvent\", { event, chainId });\n  };\n\n  public disconnect: IEngine[\"disconnect\"] = async (params) => {\n    this.isInitialized();\n    await this.isValidDisconnect(params);\n    const { topic } = params;\n    if (this.client.session.keys.includes(topic)) {\n      await this.sendRequest(topic, \"wc_sessionDelete\", getSdkError(\"USER_DISCONNECTED\"));\n      await this.deleteSession(topic);\n    } else {\n      await this.client.core.pairing.disconnect({ topic });\n    }\n  };\n\n  public find: IEngine[\"find\"] = (params) => {\n    this.isInitialized();\n    return this.client.session.getAll().filter((session) => isSessionCompatible(session, params));\n  };\n\n  public getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"] = () => {\n    this.isInitialized();\n    return this.client.pendingRequest.getAll();\n  };\n\n  // ---------- Private Helpers --------------------------------------- //\n\n  private cleanupDuplicatePairings: EnginePrivate[\"cleanupDuplicatePairings\"] = async (\n    session: SessionTypes.Struct,\n  ) => {\n    try {\n      const pairing = this.client.core.pairing.pairings.get(session.pairingTopic);\n      const allPairings = this.client.core.pairing.pairings.getAll();\n      const duplicates = allPairings.filter(\n        (p) =>\n          p.peerMetadata?.url &&\n          p.peerMetadata?.url === session.self.metadata.url &&\n          p.topic !== pairing.topic,\n      );\n      if (duplicates.length === 0) return;\n      this.client.logger.info(`Cleaning up ${duplicates.length} duplicate pairing(s)`);\n      await Promise.all(\n        duplicates.map((p) => this.client.core.pairing.disconnect({ topic: p.topic })),\n      );\n      this.client.logger.info(`Duplicate pairings clean up finished`);\n    } catch (error) {\n      this.client.logger.error(error);\n    }\n  };\n\n  private deleteSession: EnginePrivate[\"deleteSession\"] = async (topic, expirerHasDeleted) => {\n    const { self } = this.client.session.get(topic);\n    // Await the unsubscribe first to avoid deleting the symKey too early below.\n    await this.client.core.relayer.unsubscribe(topic);\n    await Promise.all([\n      this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\")),\n      this.client.core.crypto.deleteKeyPair(self.publicKey),\n      this.client.core.crypto.deleteSymKey(topic),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(topic),\n    ]);\n  };\n\n  private deleteProposal: EnginePrivate[\"deleteProposal\"] = async (id, expirerHasDeleted) => {\n    await Promise.all([\n      this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\")),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private deletePendingSessionRequest: EnginePrivate[\"deletePendingSessionRequest\"] = async (\n    id,\n    reason,\n    expirerHasDeleted = false,\n  ) => {\n    await Promise.all([\n      this.client.pendingRequest.delete(id, reason),\n      expirerHasDeleted ? Promise.resolve() : this.client.core.expirer.del(id),\n    ]);\n  };\n\n  private setExpiry: EnginePrivate[\"setExpiry\"] = async (topic, expiry) => {\n    if (this.client.session.keys.includes(topic)) {\n      await this.client.session.update(topic, { expiry });\n    }\n    this.client.core.expirer.set(topic, expiry);\n  };\n\n  private setProposal: EnginePrivate[\"setProposal\"] = async (id, proposal) => {\n    await this.client.proposal.set(id, proposal);\n    this.client.core.expirer.set(id, proposal.expiry);\n  };\n\n  private setPendingSessionRequest: EnginePrivate[\"setPendingSessionRequest\"] = async (\n    pendingRequest: PendingRequestTypes.Struct,\n  ) => {\n    const expiry = ENGINE_RPC_OPTS.wc_sessionRequest.req.ttl;\n    const { id, topic, params } = pendingRequest;\n    await this.client.pendingRequest.set(id, {\n      id,\n      topic,\n      params,\n    });\n    if (expiry) this.client.core.expirer.set(id, calcExpiry(expiry));\n  };\n\n  private sendRequest: EnginePrivate[\"sendRequest\"] = async (topic, method, params, expiry) => {\n    const payload = formatJsonRpcRequest(method, params);\n    if (isBrowser() && METHODS_TO_VERIFY.includes(method)) {\n      const hash = hashMessage(JSON.stringify(payload));\n      await this.client.core.verify.register({ attestationId: hash });\n    }\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const opts = ENGINE_RPC_OPTS[method].req;\n    if (expiry) opts.ttl = expiry;\n    this.client.core.history.set(topic, payload);\n    this.client.core.relayer.publish(topic, message, opts);\n    return payload.id;\n  };\n\n  private sendResult: EnginePrivate[\"sendResult\"] = async (id, topic, result) => {\n    const payload = formatJsonRpcResult(id, result);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private sendError: EnginePrivate[\"sendError\"] = async (id, topic, error) => {\n    const payload = formatJsonRpcError(id, error);\n    const message = await this.client.core.crypto.encode(topic, payload);\n    const record = await this.client.core.history.get(topic, id);\n    const opts = ENGINE_RPC_OPTS[record.request.method].res;\n    // await is intentionally omitted to speed up performance\n    this.client.core.relayer.publish(topic, message, opts);\n    await this.client.core.history.resolve(payload);\n  };\n\n  private cleanup: EnginePrivate[\"cleanup\"] = async () => {\n    const sessionTopics: string[] = [];\n    const proposalIds: number[] = [];\n    this.client.session.getAll().forEach((session) => {\n      if (isExpired(session.expiry)) sessionTopics.push(session.topic);\n    });\n    this.client.proposal.getAll().forEach((proposal) => {\n      if (isExpired(proposal.expiry)) proposalIds.push(proposal.id);\n    });\n    await Promise.all([\n      ...sessionTopics.map((topic) => this.deleteSession(topic)),\n      ...proposalIds.map((id) => this.deleteProposal(id)),\n    ]);\n  };\n\n  private isInitialized() {\n    if (!this.initialized) {\n      const { message } = getInternalError(\"NOT_INITIALIZED\", this.name);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Relay Events Router ----------------------------------- //\n\n  private registerRelayerEvents() {\n    this.client.core.relayer.on(\n      RELAYER_EVENTS.message,\n      async (event: RelayerTypes.MessageEvent) => {\n        const { topic, message } = event;\n\n        // messages of certain types should be ignored as they are handled by their respective SDKs\n        if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(message))) {\n          return;\n        }\n\n        const payload = await this.client.core.crypto.decode(topic, message);\n\n        if (isJsonRpcRequest(payload)) {\n          this.client.core.history.set(topic, payload);\n          this.onRelayEventRequest({ topic, payload });\n        } else if (isJsonRpcResponse(payload)) {\n          await this.client.core.history.resolve(payload);\n          this.onRelayEventResponse({ topic, payload });\n        }\n      },\n    );\n  }\n\n  private onRelayEventRequest: EnginePrivate[\"onRelayEventRequest\"] = (event) => {\n    const { topic, payload } = event;\n    const reqMethod = payload.method as JsonRpcTypes.WcMethod;\n\n    switch (reqMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeRequest(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleRequest(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateRequest(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendRequest(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingRequest(topic, payload);\n      case \"wc_sessionDelete\":\n        return this.onSessionDeleteRequest(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequest(topic, payload);\n      case \"wc_sessionEvent\":\n        return this.onSessionEventRequest(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported request method ${reqMethod}`);\n    }\n  };\n\n  private onRelayEventResponse: EnginePrivate[\"onRelayEventResponse\"] = async (event) => {\n    const { topic, payload } = event;\n    const record = await this.client.core.history.get(topic, payload.id);\n    const resMethod = record.request.method as JsonRpcTypes.WcMethod;\n\n    switch (resMethod) {\n      case \"wc_sessionPropose\":\n        return this.onSessionProposeResponse(topic, payload);\n      case \"wc_sessionSettle\":\n        return this.onSessionSettleResponse(topic, payload);\n      case \"wc_sessionUpdate\":\n        return this.onSessionUpdateResponse(topic, payload);\n      case \"wc_sessionExtend\":\n        return this.onSessionExtendResponse(topic, payload);\n      case \"wc_sessionPing\":\n        return this.onSessionPingResponse(topic, payload);\n      case \"wc_sessionRequest\":\n        return this.onSessionRequestResponse(topic, payload);\n      default:\n        return this.client.logger.info(`Unsupported response method ${resMethod}`);\n    }\n  };\n\n  // ---------- Relay Events Handlers --------------------------------- //\n\n  private onSessionProposeRequest: EnginePrivate[\"onSessionProposeRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidConnect({ ...payload.params });\n      const expiry = calcExpiry(FIVE_MINUTES);\n      const proposal = { id, pairingTopic: topic, expiry, ...params };\n      await this.setProposal(id, proposal);\n      const hash = hashMessage(JSON.stringify(payload));\n      const verifyContext = await this.getVerifyContext(hash, proposal.proposer.metadata);\n      this.client.events.emit(\"session_proposal\", { id, params: proposal, verifyContext });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionProposeResponse: EnginePrivate[\"onSessionProposeResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      const { result } = payload;\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", result });\n      const proposal = this.client.proposal.get(id);\n      this.client.logger.trace({ type: \"method\", method: \"onSessionProposeResponse\", proposal });\n      const selfPublicKey = proposal.proposer.publicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        selfPublicKey,\n      });\n      const peerPublicKey = result.responderPublicKey;\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        peerPublicKey,\n      });\n      const sessionTopic = await this.client.core.crypto.generateSharedKey(\n        selfPublicKey,\n        peerPublicKey,\n      );\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        sessionTopic,\n      });\n      const subscriptionId = await this.client.core.relayer.subscribe(sessionTopic);\n      this.client.logger.trace({\n        type: \"method\",\n        method: \"onSessionProposeResponse\",\n        subscriptionId,\n      });\n      await this.client.core.pairing.activate({ topic });\n    } else if (isJsonRpcError(payload)) {\n      await this.client.proposal.delete(id, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_connect\"), { error: payload.error });\n    }\n  };\n\n  private onSessionSettleRequest: EnginePrivate[\"onSessionSettleRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidSessionSettleRequest(params);\n      const {\n        relay,\n        controller,\n        expiry,\n        namespaces,\n        requiredNamespaces,\n        optionalNamespaces,\n        sessionProperties,\n        pairingTopic,\n      } = payload.params;\n      const session = {\n        topic,\n        relay,\n        expiry,\n        namespaces,\n        acknowledged: true,\n        pairingTopic,\n        requiredNamespaces,\n        optionalNamespaces,\n        controller: controller.publicKey,\n        self: {\n          publicKey: \"\",\n          metadata: this.client.metadata,\n        },\n        peer: {\n          publicKey: controller.publicKey,\n          metadata: controller.metadata,\n        },\n        ...(sessionProperties && { sessionProperties }),\n      };\n      await this.sendResult<\"wc_sessionSettle\">(payload.id, topic, true);\n      this.events.emit(engineEvent(\"session_connect\"), { session });\n      this.cleanupDuplicatePairings(session);\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionSettleResponse: EnginePrivate[\"onSessionSettleResponse\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      await this.client.session.update(topic, { acknowledged: true });\n      this.events.emit(engineEvent(\"session_approve\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      await this.client.session.delete(topic, getSdkError(\"USER_DISCONNECTED\"));\n      this.events.emit(engineEvent(\"session_approve\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionUpdateRequest: EnginePrivate[\"onSessionUpdateRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { params, id } = payload;\n    try {\n      this.isValidUpdate({ topic, ...params });\n      await this.client.session.update(topic, { namespaces: params.namespaces });\n      await this.sendResult<\"wc_sessionUpdate\">(id, topic, true);\n      this.client.events.emit(\"session_update\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionUpdateResponse: EnginePrivate[\"onSessionUpdateResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_update\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionExtendRequest: EnginePrivate[\"onSessionExtendRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidExtend({ topic });\n      await this.setExpiry(topic, calcExpiry(SESSION_EXPIRY));\n      await this.sendResult<\"wc_sessionExtend\">(id, topic, true);\n      this.client.events.emit(\"session_extend\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionExtendResponse: EnginePrivate[\"onSessionExtendResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), {});\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_extend\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionPingRequest: EnginePrivate[\"onSessionPingRequest\"] = async (topic, payload) => {\n    const { id } = payload;\n    try {\n      this.isValidPing({ topic });\n      await this.sendResult<\"wc_sessionPing\">(id, topic, true);\n      this.client.events.emit(\"session_ping\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionPingResponse: EnginePrivate[\"onSessionPingResponse\"] = (_topic, payload) => {\n    const { id } = payload;\n    // put at the end of the stack to avoid a race condition\n    // where session_ping listener is not yet initialized\n    setTimeout(() => {\n      if (isJsonRpcResult(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), {});\n      } else if (isJsonRpcError(payload)) {\n        this.events.emit(engineEvent(\"session_ping\", id), { error: payload.error });\n      }\n    }, 500);\n  };\n\n  private onSessionDeleteRequest: EnginePrivate[\"onSessionDeleteRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    try {\n      this.isValidDisconnect({ topic, reason: payload.params });\n      await Promise.all([\n        new Promise((resolve) => {\n          // RPC request needs to happen before deletion as it utalises session encryption\n          this.client.core.relayer.once(RELAYER_EVENTS.publish, async () => {\n            resolve(await this.deleteSession(topic));\n          });\n        }),\n        this.sendResult<\"wc_sessionDelete\">(id, topic, true),\n      ]);\n      this.client.events.emit(\"session_delete\", { id, topic });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequest: EnginePrivate[\"onSessionRequest\"] = async (topic, payload) => {\n    const { id, params } = payload;\n    try {\n      this.isValidRequest({ topic, ...params });\n      await this.setPendingSessionRequest({ id, topic, params });\n      const hash = hashMessage(JSON.stringify(payload));\n      const session = this.client.session.get(topic);\n      const verifyContext = await this.getVerifyContext(hash, session.peer.metadata);\n      this.client.events.emit(\"session_request\", { id, topic, params, verifyContext });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  private onSessionRequestResponse: EnginePrivate[\"onSessionRequestResponse\"] = (\n    _topic,\n    payload,\n  ) => {\n    const { id } = payload;\n    if (isJsonRpcResult(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { result: payload.result });\n    } else if (isJsonRpcError(payload)) {\n      this.events.emit(engineEvent(\"session_request\", id), { error: payload.error });\n    }\n  };\n\n  private onSessionEventRequest: EnginePrivate[\"onSessionEventRequest\"] = async (\n    topic,\n    payload,\n  ) => {\n    const { id, params } = payload;\n    try {\n      this.isValidEmit({ topic, ...params });\n      this.client.events.emit(\"session_event\", { id, topic, params });\n    } catch (err: any) {\n      await this.sendError(id, topic, err);\n      this.client.logger.error(err);\n    }\n  };\n\n  // ---------- Expirer Events ---------------------------------------- //\n\n  private registerExpirerEvents() {\n    this.client.core.expirer.on(EXPIRER_EVENTS.expired, async (event: ExpirerTypes.Expiration) => {\n      const { topic, id } = parseExpirerTarget(event.target);\n      if (id && this.client.pendingRequest.keys.includes(id)) {\n        return await this.deletePendingSessionRequest(id, getInternalError(\"EXPIRED\"), true);\n      }\n\n      if (topic) {\n        if (this.client.session.keys.includes(topic)) {\n          await this.deleteSession(topic, true);\n          this.client.events.emit(\"session_expire\", { topic });\n        }\n      } else if (id) {\n        await this.deleteProposal(id, true);\n        this.client.events.emit(\"proposal_expire\", { id });\n      }\n    });\n  }\n\n  // ---------- Validation Helpers ------------------------------------ //\n  private isValidPairingTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.core.pairing.pairings.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.core.pairing.pairings.get(topic).expiry)) {\n      // await this.deletePairing(topic);\n      const { message } = getInternalError(\"EXPIRED\", `pairing topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionTopic(topic: any) {\n    if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.session.keys.includes(topic)) {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n    if (isExpired(this.client.session.get(topic).expiry)) {\n      await this.deleteSession(topic);\n      const { message } = getInternalError(\"EXPIRED\", `session topic: ${topic}`);\n      throw new Error(message);\n    }\n  }\n\n  private async isValidSessionOrPairingTopic(topic: string) {\n    if (this.client.session.keys.includes(topic)) {\n      await this.isValidSessionTopic(topic);\n    } else if (this.client.core.pairing.pairings.keys.includes(topic)) {\n      this.isValidPairingTopic(topic);\n    } else if (!isValidString(topic, false)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `session or pairing topic should be a string: ${topic}`,\n      );\n      throw new Error(message);\n    } else {\n      const { message } = getInternalError(\n        \"NO_MATCHING_KEY\",\n        `session or pairing topic doesn't exist: ${topic}`,\n      );\n      throw new Error(message);\n    }\n  }\n\n  private async isValidProposalId(id: any) {\n    if (!isValidId(id)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `proposal id should be a number: ${id}`,\n      );\n      throw new Error(message);\n    }\n    if (!this.client.proposal.keys.includes(id)) {\n      const { message } = getInternalError(\"NO_MATCHING_KEY\", `proposal id doesn't exist: ${id}`);\n      throw new Error(message);\n    }\n    if (isExpired(this.client.proposal.get(id).expiry)) {\n      await this.deleteProposal(id);\n      const { message } = getInternalError(\"EXPIRED\", `proposal id: ${id}`);\n      throw new Error(message);\n    }\n  }\n\n  // ---------- Validation  ------------------------------------------- //\n\n  private isValidConnect: EnginePrivate[\"isValidConnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `connect() params: ${JSON.stringify(params)}`,\n      );\n      throw new Error(message);\n    }\n    const { pairingTopic, requiredNamespaces, optionalNamespaces, sessionProperties, relays } =\n      params;\n    if (!isUndefined(pairingTopic)) await this.isValidPairingTopic(pairingTopic);\n\n    if (!isValidRelays(relays, true)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `connect() relays: ${relays}`);\n      throw new Error(message);\n    }\n\n    // validate required namespaces only if they are defined\n    if (!isUndefined(requiredNamespaces) && isValidObject(requiredNamespaces) !== 0) {\n      this.validateNamespaces(requiredNamespaces, \"requiredNamespaces\");\n    }\n\n    // validate optional namespaces only if they are defined\n    if (!isUndefined(optionalNamespaces) && isValidObject(optionalNamespaces) !== 0) {\n      this.validateNamespaces(optionalNamespaces, \"optionalNamespaces\");\n    }\n\n    // validate session properties only if they are defined\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private validateNamespaces = (\n    namespaces: ProposalTypes.RequiredNamespaces | ProposalTypes.OptionalNamespaces,\n    type: string,\n  ) => {\n    const validRequiredNamespacesError = isValidRequiredNamespaces(namespaces, \"connect()\", type);\n    if (validRequiredNamespacesError) throw new Error(validRequiredNamespacesError.message);\n  };\n\n  private isValidApprove: EnginePrivate[\"isValidApprove\"] = async (params) => {\n    if (!isValidParams(params))\n      throw new Error(\n        getInternalError(\"MISSING_OR_INVALID\", `approve() params: ${params}`).message,\n      );\n    const { id, namespaces, relayProtocol, sessionProperties } = params;\n    await this.isValidProposalId(id);\n    const proposal = this.client.proposal.get(id);\n    const validNamespacesError = isValidNamespaces(namespaces, \"approve()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      proposal.requiredNamespaces,\n      namespaces,\n      \"approve()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    if (!isValidString(relayProtocol, true)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `approve() relayProtocol: ${relayProtocol}`,\n      );\n      throw new Error(message);\n    }\n\n    if (!isUndefined(sessionProperties)) {\n      this.validateSessionProps(sessionProperties, \"sessionProperties\");\n    }\n  };\n\n  private isValidReject: EnginePrivate[\"isValidReject\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `reject() params: ${params}`);\n      throw new Error(message);\n    }\n    const { id, reason } = params;\n    await this.isValidProposalId(id);\n    if (!isValidErrorReason(reason)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `reject() reason: ${JSON.stringify(reason)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidSessionSettleRequest: EnginePrivate[\"isValidSessionSettleRequest\"] = (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() params: ${params}`,\n      );\n      throw new Error(message);\n    }\n    const { relay, controller, namespaces, expiry } = params;\n    if (!isValidRelay(relay)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `onSessionSettleRequest() relay protocol should be a string`,\n      );\n      throw new Error(message);\n    }\n    const validControllerError = isValidController(controller, \"onSessionSettleRequest()\");\n    if (validControllerError) throw new Error(validControllerError.message);\n    const validNamespacesError = isValidNamespaces(namespaces, \"onSessionSettleRequest()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    if (isExpired(expiry)) {\n      const { message } = getInternalError(\"EXPIRED\", `onSessionSettleRequest()`);\n      throw new Error(message);\n    }\n  };\n\n  private isValidUpdate: EnginePrivate[\"isValidUpdate\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `update() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, namespaces } = params;\n    await this.isValidSessionTopic(topic);\n    const session = this.client.session.get(topic);\n    const validNamespacesError = isValidNamespaces(namespaces, \"update()\");\n    if (validNamespacesError) throw new Error(validNamespacesError.message);\n    const conformingNamespacesError = isConformingNamespaces(\n      session.requiredNamespaces,\n      namespaces,\n      \"update()\",\n    );\n    if (conformingNamespacesError) throw new Error(conformingNamespacesError.message);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidExtend: EnginePrivate[\"isValidExtend\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `extend() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionTopic(topic);\n    // TODO(ilja) - check if wallet\n  };\n\n  private isValidRequest: EnginePrivate[\"isValidRequest\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, request, chainId, expiry } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `request() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidRequest(request)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() ${JSON.stringify(request)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesRequest(namespaces, chainId, request.method)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() method: ${request.method}`,\n      );\n      throw new Error(message);\n    }\n    if (expiry && !isValidRequestExpiry(expiry, SESSION_REQUEST_EXPIRY_BOUNDARIES)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `request() expiry: ${expiry}. Expiry must be a number (in seconds) between ${SESSION_REQUEST_EXPIRY_BOUNDARIES.min} and ${SESSION_REQUEST_EXPIRY_BOUNDARIES.max}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidRespond: EnginePrivate[\"isValidRespond\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `respond() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, response } = params;\n    await this.isValidSessionTopic(topic);\n    if (!isValidResponse(response)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `respond() response: ${JSON.stringify(response)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidPing: EnginePrivate[\"isValidPing\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `ping() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private isValidEmit: EnginePrivate[\"isValidEmit\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic, event, chainId } = params;\n    await this.isValidSessionTopic(topic);\n    const { namespaces } = this.client.session.get(topic);\n    if (!isValidNamespacesChainId(namespaces, chainId)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `emit() chainId: ${chainId}`);\n      throw new Error(message);\n    }\n    if (!isValidEvent(event)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n    if (!isValidNamespacesEvent(namespaces, chainId, event.name)) {\n      const { message } = getInternalError(\n        \"MISSING_OR_INVALID\",\n        `emit() event: ${JSON.stringify(event)}`,\n      );\n      throw new Error(message);\n    }\n  };\n\n  private isValidDisconnect: EnginePrivate[\"isValidDisconnect\"] = async (params) => {\n    if (!isValidParams(params)) {\n      const { message } = getInternalError(\"MISSING_OR_INVALID\", `disconnect() params: ${params}`);\n      throw new Error(message);\n    }\n    const { topic } = params;\n    await this.isValidSessionOrPairingTopic(topic);\n  };\n\n  private getVerifyContext = async (hash: string, metadata: CoreTypes.Metadata) => {\n    const context: Verify.Context = {\n      verified: {\n        verifyUrl: metadata.verifyUrl || \"\",\n        validation: \"UNKNOWN\",\n        origin: metadata.url || \"\",\n      },\n    };\n\n    try {\n      const origin = await this.client.core.verify.resolve({\n        attestationId: hash,\n        verifyUrl: metadata.verifyUrl,\n      });\n      if (origin) {\n        context.verified.origin = origin;\n        context.verified.validation = origin === metadata.url ? \"VALID\" : \"INVALID\";\n      }\n    } catch (e) {\n      this.client.logger.error(e);\n    }\n\n    this.client.logger.info(`Verify context: ${JSON.stringify(context)}`);\n    return context;\n  };\n\n  private validateSessionProps = (properties: ProposalTypes.SessionProperties, type: string) => {\n    Object.values(properties).forEach((property) => {\n      if (!isValidString(property, false)) {\n        const { message } = getInternalError(\n          \"MISSING_OR_INVALID\",\n          `${type} must be in Record<string, string> format. Received: ${JSON.stringify(property)}`,\n        );\n        throw new Error(message);\n      }\n    });\n  };\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, ProposalTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, PROPOSAL_CONTEXT } from \"../constants\";\n\nexport class Proposal extends Store<number, ProposalTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, PROPOSAL_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, SessionTypes } from \"@walletconnect/types\";\n\nimport { SIGN_CLIENT_STORAGE_PREFIX, SESSION_CONTEXT } from \"../constants\";\n\nexport class Session extends Store<string, SessionTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(core, logger, SESSION_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX);\n  }\n}\n","import { Store } from \"@walletconnect/core\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore, PendingRequestTypes } from \"@walletconnect/types\";\nimport { REQUEST_CONTEXT, SIGN_CLIENT_STORAGE_PREFIX } from \"../constants\";\n\nexport class PendingRequest extends Store<number, PendingRequestTypes.Struct> {\n  constructor(public core: ICore, public logger: Logger) {\n    super(\n      core,\n      logger,\n      REQUEST_CONTEXT,\n      SIGN_CLIENT_STORAGE_PREFIX,\n      (val: PendingRequestTypes.Struct) => val.id,\n    );\n  }\n}\n","import { Core } from \"@walletconnect/core\";\nimport {\n  generateChildLogger,\n  getDefaultLoggerOptions,\n  getLoggerContext,\n  pino,\n} from \"@walletconnect/logger\";\nimport { SignClientTypes, ISignClient, ISignClientEvents, EngineTypes } from \"@walletconnect/types\";\nimport { getAppMetadata } from \"@walletconnect/utils\";\nimport { EventEmitter } from \"events\";\nimport { SIGN_CLIENT_DEFAULT, SIGN_CLIENT_PROTOCOL, SIGN_CLIENT_VERSION } from \"./constants\";\nimport { Engine, PendingRequest, Proposal, Session } from \"./controllers\";\n\nexport class SignClient extends ISignClient {\n  public readonly protocol = SIGN_CLIENT_PROTOCOL;\n  public readonly version = SIGN_CLIENT_VERSION;\n  public readonly name: ISignClient[\"name\"] = SIGN_CLIENT_DEFAULT.name;\n  public readonly metadata: ISignClient[\"metadata\"];\n\n  public core: ISignClient[\"core\"];\n  public logger: ISignClient[\"logger\"];\n  public events: ISignClient[\"events\"] = new EventEmitter();\n  public engine: ISignClient[\"engine\"];\n  public session: ISignClient[\"session\"];\n  public proposal: ISignClient[\"proposal\"];\n  public pendingRequest: ISignClient[\"pendingRequest\"];\n\n  static async init(opts?: SignClientTypes.Options) {\n    const client = new SignClient(opts);\n    await client.initialize();\n\n    return client;\n  }\n\n  constructor(opts?: SignClientTypes.Options) {\n    super(opts);\n\n    this.name = opts?.name || SIGN_CLIENT_DEFAULT.name;\n    this.metadata = opts?.metadata || getAppMetadata();\n\n    const logger =\n      typeof opts?.logger !== \"undefined\" && typeof opts?.logger !== \"string\"\n        ? opts.logger\n        : pino(getDefaultLoggerOptions({ level: opts?.logger || SIGN_CLIENT_DEFAULT.logger }));\n\n    this.core = opts?.core || new Core(opts);\n    this.logger = generateChildLogger(logger, this.name);\n    this.session = new Session(this.core, this.logger);\n    this.proposal = new Proposal(this.core, this.logger);\n    this.pendingRequest = new PendingRequest(this.core, this.logger);\n    this.engine = new Engine(this);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get pairing() {\n    return this.core.pairing.pairings;\n  }\n\n  // ---------- Events ----------------------------------------------- //\n\n  public on: ISignClientEvents[\"on\"] = (name, listener) => {\n    return this.events.on(name, listener);\n  };\n\n  public once: ISignClientEvents[\"once\"] = (name, listener) => {\n    return this.events.once(name, listener);\n  };\n\n  public off: ISignClientEvents[\"off\"] = (name, listener) => {\n    return this.events.off(name, listener);\n  };\n\n  public removeListener: ISignClientEvents[\"removeListener\"] = (name, listener) => {\n    return this.events.removeListener(name, listener);\n  };\n\n  public removeAllListeners: ISignClientEvents[\"removeAllListeners\"] = (name) => {\n    return this.events.removeAllListeners(name);\n  };\n\n  // ---------- Engine ----------------------------------------------- //\n\n  public connect: ISignClient[\"connect\"] = async (params) => {\n    try {\n      return await this.engine.connect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public pair: ISignClient[\"pair\"] = async (params) => {\n    try {\n      return await this.engine.pair(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public approve: ISignClient[\"approve\"] = async (params) => {\n    try {\n      return await this.engine.approve(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public reject: ISignClient[\"reject\"] = async (params) => {\n    try {\n      return await this.engine.reject(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public update: ISignClient[\"update\"] = async (params) => {\n    try {\n      return await this.engine.update(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public extend: ISignClient[\"extend\"] = async (params) => {\n    try {\n      return await this.engine.extend(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public request: ISignClient[\"request\"] = async <T>(params: EngineTypes.RequestParams) => {\n    try {\n      return await this.engine.request<T>(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public respond: ISignClient[\"respond\"] = async (params) => {\n    try {\n      return await this.engine.respond(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public ping: ISignClient[\"ping\"] = async (params) => {\n    try {\n      return await this.engine.ping(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public emit: ISignClient[\"emit\"] = async (params) => {\n    try {\n      return await this.engine.emit(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public disconnect: ISignClient[\"disconnect\"] = async (params) => {\n    try {\n      return await this.engine.disconnect(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public find: ISignClient[\"find\"] = (params) => {\n    try {\n      return this.engine.find(params);\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  public getPendingSessionRequests: ISignClient[\"getPendingSessionRequests\"] = () => {\n    try {\n      return this.engine.getPendingSessionRequests();\n    } catch (error: any) {\n      this.logger.error(error.message);\n      throw error;\n    }\n  };\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize() {\n    this.logger.trace(`Initialized`);\n    try {\n      await this.core.start();\n      await this.session.init();\n      await this.proposal.init();\n      await this.pendingRequest.init();\n      await this.engine.init();\n      this.core.verify.init({ verifyUrl: this.metadata.verifyUrl });\n      this.logger.info(`SignClient Initialization Success`);\n    } catch (error: any) {\n      this.logger.info(`SignClient Initialization Failure`);\n      this.logger.error(error.message);\n      throw error;\n    }\n  }\n}\n","import { SignClient as Client } from \"./client\";\n\nexport * from \"./constants\";\n\nexport const SignClient = Client;\nexport default Client;\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}