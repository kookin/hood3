{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ByteVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst byteArray_1 = require(\"./byteArray\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * ByteVector: Immutable alias of Vector[byte, N]\n * - Notation: `ByteVector[N]`\n * - Value: `Uint8Array`\n * - View: `Uint8Array`\n * - ViewDU: `Uint8Array`\n *\n * ByteVector is an immutable value which is represented by a Uint8Array for memory efficiency and performance.\n * Note: Consumers of this type MUST never mutate the `Uint8Array` representation of a ByteVector.\n *\n * For a `ByteVectorType` with mutability, use `VectorBasicType(byteType)`\n */\nclass ByteVectorType extends byteArray_1.ByteArrayType {\n  constructor(lengthBytes, opts) {\n    super();\n    this.lengthBytes = lengthBytes;\n    this.isList = false;\n    if (lengthBytes === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = opts?.typeName ?? `ByteVector[${lengthBytes}]`;\n    this.maxChunkCount = Math.ceil(this.lengthBytes / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    this.depth = this.chunkDepth;\n    this.fixedSize = this.lengthBytes;\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize;\n  }\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(ByteVectorType, opts.typeName))(limitBits, opts);\n  }\n  // Views: inherited from ByteArrayType\n  // Serialization + deserialization\n  value_serializedSize() {\n    return this.fixedSize;\n  }\n  // value_* inherited from ByteArrayType\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.chunkDepth, 0, this.maxChunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n    return offset + this.fixedSize;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    return persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, data.dataView, start, end);\n  }\n  tree_getByteLen() {\n    return this.lengthBytes;\n  }\n  // Merkleization: inherited from ByteArrayType\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from ByteArrayType\n  assertValidSize(size) {\n    if (size !== this.lengthBytes) {\n      throw Error(`ByteVector invalid size ${size} expected ${this.lengthBytes}`);\n    }\n  }\n}\nexports.ByteVectorType = ByteVectorType;","map":{"version":3,"names":["persistent_merkle_tree_1","require","merkleize_1","named_1","byteArray_1","ByteVectorType","ByteArrayType","constructor","lengthBytes","opts","isList","Error","typeName","maxChunkCount","Math","ceil","chunkDepth","maxChunksToDepth","depth","fixedSize","minSize","maxSize","named","limitBits","namedClass","value_serializedSize","tree_serializedSize","tree_serializeToBytes","output","offset","node","nodes","getNodesAtDepth","packedNodeRootsToBytes","dataView","tree_deserializeFromBytes","data","start","end","assertValidSize","packedRootsBytesToNode","tree_getByteLen","size","exports"],"sources":["../../src/type/byteVector.ts"],"sourcesContent":[null],"mappings":";;;;;;AAAA,MAAAA,wBAAA,GAAAC,OAAA;AACA,MAAAC,WAAA,GAAAD,OAAA;AAEA,MAAAE,OAAA,GAAAF,OAAA;AAEA,MAAAG,WAAA,GAAAH,OAAA;AAQA;AAEA;;;;;;;;;;;;AAYA,MAAaI,cAAe,SAAQD,WAAA,CAAAE,aAAa;EAW/CC,YAAqBC,WAAmB,EAAEC,IAAwB;IAChE,KAAK,EAAE;IADY,KAAAD,WAAW,GAAXA,WAAW;IAFvB,KAAAE,MAAM,GAAG,KAAK;IAKrB,IAAIF,WAAW,KAAK,CAAC,EAAE,MAAMG,KAAK,CAAC,2BAA2B,CAAC;IAE/D,IAAI,CAACC,QAAQ,GAAGH,IAAI,EAAEG,QAAQ,IAAI,cAAcJ,WAAW,GAAG;IAC9D,IAAI,CAACK,aAAa,GAAGC,IAAI,CAACC,IAAI,CAAC,IAAI,CAACP,WAAW,GAAG,EAAE,CAAC;IACrD,IAAI,CAACQ,UAAU,GAAGd,WAAA,CAAAe,gBAAgB,CAAC,IAAI,CAACJ,aAAa,CAAC;IACtD,IAAI,CAACK,KAAK,GAAG,IAAI,CAACF,UAAU;IAC5B,IAAI,CAACG,SAAS,GAAG,IAAI,CAACX,WAAW;IACjC,IAAI,CAACY,OAAO,GAAG,IAAI,CAACD,SAAS;IAC7B,IAAI,CAACE,OAAO,GAAG,IAAI,CAACF,SAAS;EAC/B;EAEA,OAAOG,KAAKA,CAACC,SAAiB,EAAEd,IAA4C;IAC1E,OAAO,KAAKN,OAAA,CAAAqB,UAAU,CAACnB,cAAc,EAAEI,IAAI,CAACG,QAAQ,CAAC,EAAEW,SAAS,EAAEd,IAAI,CAAC;EACzE;EAEA;EAEA;EAEAgB,oBAAoBA,CAAA;IAClB,OAAO,IAAI,CAACN,SAAS;EACvB;EAEA;EAEAO,mBAAmBA,CAAA;IACjB,OAAO,IAAI,CAACP,SAAS;EACvB;EAEAQ,qBAAqBA,CAACC,MAAiB,EAAEC,MAAc,EAAEC,IAAU;IACjE,MAAMC,KAAK,GAAG/B,wBAAA,CAAAgC,eAAe,CAACF,IAAI,EAAE,IAAI,CAACd,UAAU,EAAE,CAAC,EAAE,IAAI,CAACH,aAAa,CAAC;IAC3Eb,wBAAA,CAAAiC,sBAAsB,CAACL,MAAM,CAACM,QAAQ,EAAEL,MAAM,EAAE,IAAI,CAACV,SAAS,EAAEY,KAAK,CAAC;IACtE,OAAOF,MAAM,GAAG,IAAI,CAACV,SAAS;EAChC;EAEAgB,yBAAyBA,CAACC,IAAe,EAAEC,KAAa,EAAEC,GAAW;IACnE,IAAI,CAACC,eAAe,CAACD,GAAG,GAAGD,KAAK,CAAC;IACjC,OAAOrC,wBAAA,CAAAwC,sBAAsB,CAAC,IAAI,CAACxB,UAAU,EAAEoB,IAAI,CAACF,QAAQ,EAAEG,KAAK,EAAEC,GAAG,CAAC;EAC3E;EAEAG,eAAeA,CAAA;IACb,OAAO,IAAI,CAACjC,WAAW;EACzB;EAEA;EAEA;EAEA;EAEU+B,eAAeA,CAACG,IAAY;IACpC,IAAIA,IAAI,KAAK,IAAI,CAAClC,WAAW,EAAE;MAC7B,MAAMG,KAAK,CAAC,2BAA2B+B,IAAI,aAAa,IAAI,CAAClC,WAAW,EAAE,CAAC;;EAE/E;;AApEFmC,OAAA,CAAAtC,cAAA,GAAAA,cAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}