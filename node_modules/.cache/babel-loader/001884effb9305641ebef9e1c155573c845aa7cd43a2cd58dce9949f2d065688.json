{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.treePostProcessFromProofNode = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\n/** Duplicated partial declaration to break circular dependency with CompositeType */\nfunction isCompositeType(type) {\n  return !type.isBasic;\n}\n/**\n * Navigates and mutates nodes to post process a tree created with `Tree.createFromProof`.\n * Tree returns regular a tree with only BranchNode and LeafNode instances. However, SSZ features\n * non-standard nodes that make proofs for those types to be un-usable. This include:\n * - BranchNodeStruct: Must contain complete data `tree_fromProofNode` transforms a BranchNode and\n *   all of its data into a single BranchNodeStruct instance.\n *\n * @param bitstring Bitstring without the leading \"1\", since it's only used to compute horizontal indexes.\n */\nfunction treePostProcessFromProofNode(node, type) {\n  let bitstring = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let currentDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  // Must run tree_fromProofNode on the first received node (i.e. Validator object)\n  if (currentDepth === 0) {\n    const nodePost = type.tree_fromProofNode(node);\n    if (nodePost.done) {\n      return nodePost.node;\n    } else {\n      node = nodePost.node;\n    }\n  }\n  const atTypeDepth = type.depth === currentDepth;\n  if (node.isLeaf()) {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      // If this type merkleized fits in a single chunk then this LeafNode includes all data\n      if (childType.maxChunkCount === 1 && isCompositeType(childType)) {\n        return childType.tree_fromProofNode(node).node;\n      }\n      // Witness node\n      else {\n        return node;\n      }\n    }\n    // LeafNode not at type depth is a witness or a length / selector nodes\n    else {\n      return node;\n    }\n  } else {\n    if (atTypeDepth) {\n      const jsonPathProp = type.getIndexProperty(bitstringToIndex(bitstring));\n      if (jsonPathProp === null) {\n        // bitstring is out of bounds, witness node\n        return node;\n      }\n      const childType = type.getPropertyType(jsonPathProp);\n      if (!isCompositeType(childType)) {\n        throw Error(\"BranchNode does not map to CompositeType\");\n      }\n      const nodePost = childType.tree_fromProofNode(node);\n      // If tree_fromProofNode is the identity function, keep going, otherwise stop navigating\n      if (nodePost.done) {\n        return nodePost.node;\n      } else {\n        return treePostProcessFromProofNode(nodePost.node, childType);\n      }\n    }\n    // BranchNode at not type depth, keep navigating\n    else {\n      const leftNode = treePostProcessFromProofNode(node.left, type, bitstring + \"0\", currentDepth + 1);\n      const rightNode = treePostProcessFromProofNode(node.right, type, bitstring + \"1\", currentDepth + 1);\n      if (leftNode === node.left && rightNode === node.right) {\n        return node;\n      } else {\n        return new persistent_merkle_tree_1.BranchNode(leftNode, rightNode);\n      }\n    }\n  }\n}\nexports.treePostProcessFromProofNode = treePostProcessFromProofNode;\n/** Return the node horizontal index given a bitstring without the leading \"1\" */\nfunction bitstringToIndex(bitstring) {\n  if (bitstring === \"\") return 0;\n  return parseInt(bitstring, 2);\n}","map":{"version":3,"names":["persistent_merkle_tree_1","require","isCompositeType","type","isBasic","treePostProcessFromProofNode","node","bitstring","arguments","length","undefined","currentDepth","nodePost","tree_fromProofNode","done","atTypeDepth","depth","isLeaf","jsonPathProp","getIndexProperty","bitstringToIndex","childType","getPropertyType","maxChunkCount","Error","leftNode","left","rightNode","right","BranchNode","exports","parseInt"],"sources":["../../../src/util/proof/treePostProcessFromProofNode.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}