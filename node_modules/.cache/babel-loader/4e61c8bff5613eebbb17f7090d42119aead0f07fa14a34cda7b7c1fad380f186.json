{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromMultiProof = exports.createMultiProof = void 0;\nconst node_1 = require(\"../node\");\nconst tree_1 = require(\"../tree\");\nconst util_1 = require(\"./util\");\n/**\n * Create an multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices of leaves to include in the proof\n */\nfunction createMultiProof(rootNode, gindices) {\n  const tree = new tree_1.Tree(rootNode);\n  const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map(gindex => gindex.toString(2)), false, util_1.SortOrder.Decreasing);\n  const leafGindices = gindices.slice().sort((a, b) => a < b ? 1 : -1);\n  const leaves = leafGindices.map(gindex => tree.getRoot(gindex));\n  const witnesses = witnessGindices.map(gindex => tree.getRoot(gindex));\n  return [leaves, witnesses, leafGindices];\n}\nexports.createMultiProof = createMultiProof;\n/**\n * Recreate a `Node` given a multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param leaves leaves of a EF multiproof\n * @param witnesses witnesses of a EF multiproof\n * @param gindices generalized indices of the leaves\n */\nfunction createNodeFromMultiProof(leaves, witnesses, gindices) {\n  if (leaves.length !== gindices.length) {\n    throw new Error(\"Leaves length should equal gindices length\");\n  }\n  const leafBitstrings = gindices.map(gindex => gindex.toString(2));\n  const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);\n  if (witnessBitstrings.length !== witnesses.length) {\n    throw new Error(\"Witnesses length should equal witnesses gindices length\");\n  }\n  // Algorithm:\n  // create an object which tracks key-values for each level\n  // pre-load leaves and witnesses into the level object\n  // level by level, starting from the bottom,\n  // find the sibling, create the parent, store it in the next level up\n  // the root is in level 1\n  const maxLevel = Math.max(leafBitstrings[0]?.length ?? 0, witnessBitstrings[0]?.length ?? 0);\n  const levels = Object.fromEntries(Array.from({\n    length: maxLevel\n  }, (_, i) => [i + 1, {}]));\n  // preload leaves and witnesses\n  for (let i = 0; i < leafBitstrings.length; i++) {\n    const leafBitstring = leafBitstrings[i];\n    const leaf = leaves[i];\n    levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);\n  }\n  for (let i = 0; i < witnessBitstrings.length; i++) {\n    const witnessBitstring = witnessBitstrings[i];\n    const witness = witnesses[i];\n    levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);\n  }\n  for (let i = maxLevel; i > 1; i--) {\n    const level = levels[i];\n    const parentLevel = levels[i - 1];\n    for (const bitstring of Object.keys(level)) {\n      const node = level[bitstring];\n      // if the node doesn't exist, we've already processed its sibling\n      if (!node) {\n        continue;\n      }\n      const isLeft = bitstring[bitstring.length - 1] === \"0\";\n      const parentBitstring = bitstring.substring(0, bitstring.length - 1);\n      const siblingBitstring = parentBitstring + (isLeft ? \"1\" : \"0\");\n      const siblingNode = level[siblingBitstring];\n      if (!siblingNode) {\n        throw new Error(`Sibling not found: ${siblingBitstring}`);\n      }\n      // store the parent node\n      const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);\n      parentLevel[parentBitstring] = parentNode;\n      // delete the used nodes\n      delete level[bitstring];\n      delete level[siblingBitstring];\n    }\n  }\n  const root = levels[1][\"1\"];\n  if (!root) {\n    throw new Error(\"Internal consistency error: no root found\");\n  }\n  return root;\n}\nexports.createNodeFromMultiProof = createNodeFromMultiProof;","map":{"version":3,"names":["Object","defineProperty","exports","value","createNodeFromMultiProof","createMultiProof","node_1","require","tree_1","util_1","rootNode","gindices","tree","Tree","witnessGindices","computeMultiProofBitstrings","map","gindex","toString","SortOrder","Decreasing","leafGindices","slice","sort","a","b","leaves","getRoot","witnesses","length","Error","leafBitstrings","witnessBitstrings","maxLevel","Math","max","levels","fromEntries","Array","from","_","i","leafBitstring","leaf","LeafNode","fromRoot","witnessBitstring","witness","level","parentLevel","bitstring","keys","node","isLeft","parentBitstring","substring","siblingBitstring","siblingNode","parentNode","BranchNode","root"],"sources":["/hood3/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/multi.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeFromMultiProof = exports.createMultiProof = void 0;\nconst node_1 = require(\"../node\");\nconst tree_1 = require(\"../tree\");\nconst util_1 = require(\"./util\");\n/**\n * Create an multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices of leaves to include in the proof\n */\nfunction createMultiProof(rootNode, gindices) {\n    const tree = new tree_1.Tree(rootNode);\n    const witnessGindices = util_1.computeMultiProofBitstrings(gindices.map((gindex) => gindex.toString(2)), false, util_1.SortOrder.Decreasing);\n    const leafGindices = gindices.slice().sort((a, b) => (a < b ? 1 : -1));\n    const leaves = leafGindices.map((gindex) => tree.getRoot(gindex));\n    const witnesses = witnessGindices.map((gindex) => tree.getRoot(gindex));\n    return [leaves, witnesses, leafGindices];\n}\nexports.createMultiProof = createMultiProof;\n/**\n * Recreate a `Node` given a multiproof\n *\n * See https://github.com/ethereum/consensus-specs/blob/dev/ssz/merkle-proofs.md#merkle-multiproofs\n *\n * @param leaves leaves of a EF multiproof\n * @param witnesses witnesses of a EF multiproof\n * @param gindices generalized indices of the leaves\n */\nfunction createNodeFromMultiProof(leaves, witnesses, gindices) {\n    if (leaves.length !== gindices.length) {\n        throw new Error(\"Leaves length should equal gindices length\");\n    }\n    const leafBitstrings = gindices.map((gindex) => gindex.toString(2));\n    const witnessBitstrings = util_1.computeMultiProofBitstrings(leafBitstrings, false, util_1.SortOrder.Decreasing);\n    if (witnessBitstrings.length !== witnesses.length) {\n        throw new Error(\"Witnesses length should equal witnesses gindices length\");\n    }\n    // Algorithm:\n    // create an object which tracks key-values for each level\n    // pre-load leaves and witnesses into the level object\n    // level by level, starting from the bottom,\n    // find the sibling, create the parent, store it in the next level up\n    // the root is in level 1\n    const maxLevel = Math.max(leafBitstrings[0]?.length ?? 0, witnessBitstrings[0]?.length ?? 0);\n    const levels = Object.fromEntries(Array.from({ length: maxLevel }, (_, i) => [i + 1, {}]));\n    // preload leaves and witnesses\n    for (let i = 0; i < leafBitstrings.length; i++) {\n        const leafBitstring = leafBitstrings[i];\n        const leaf = leaves[i];\n        levels[leafBitstring.length][leafBitstring] = node_1.LeafNode.fromRoot(leaf);\n    }\n    for (let i = 0; i < witnessBitstrings.length; i++) {\n        const witnessBitstring = witnessBitstrings[i];\n        const witness = witnesses[i];\n        levels[witnessBitstring.length][witnessBitstring] = node_1.LeafNode.fromRoot(witness);\n    }\n    for (let i = maxLevel; i > 1; i--) {\n        const level = levels[i];\n        const parentLevel = levels[i - 1];\n        for (const bitstring of Object.keys(level)) {\n            const node = level[bitstring];\n            // if the node doesn't exist, we've already processed its sibling\n            if (!node) {\n                continue;\n            }\n            const isLeft = bitstring[bitstring.length - 1] === \"0\";\n            const parentBitstring = bitstring.substring(0, bitstring.length - 1);\n            const siblingBitstring = parentBitstring + (isLeft ? \"1\" : \"0\");\n            const siblingNode = level[siblingBitstring];\n            if (!siblingNode) {\n                throw new Error(`Sibling not found: ${siblingBitstring}`);\n            }\n            // store the parent node\n            const parentNode = isLeft ? new node_1.BranchNode(node, siblingNode) : new node_1.BranchNode(siblingNode, node);\n            parentLevel[parentBitstring] = parentNode;\n            // delete the used nodes\n            delete level[bitstring];\n            delete level[siblingBitstring];\n        }\n    }\n    const root = levels[1][\"1\"];\n    if (!root) {\n        throw new Error(\"Internal consistency error: no root found\");\n    }\n    return root;\n}\nexports.createNodeFromMultiProof = createNodeFromMultiProof;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}