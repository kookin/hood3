{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst composite_1 = require(\"./composite\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\n/* eslint-disable @typescript-eslint/member-ordering */\n/**\n * Array: ordered homogeneous collection\n */\nclass ArrayType extends composite_1.CompositeType {\n  constructor(elementType) {\n    super();\n    this.elementType = elementType;\n  }\n  defaultValue() {\n    return arrayBasic_1.value_defaultValueArray(this.elementType, this.defaultLen);\n  }\n  // Proofs\n  getPropertyType() {\n    return this.elementType;\n  }\n  getPropertyGindex(prop) {\n    if (typeof prop !== \"number\") {\n      throw Error(`Invalid array index: ${prop}`);\n    }\n    const chunkIdx = Math.floor(prop / this.itemsPerChunk);\n    return persistent_merkle_tree_1.toGindex(this.depth, BigInt(chunkIdx));\n  }\n  getIndexProperty(index) {\n    return index;\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    let length;\n    if (this.isList) {\n      if (!rootNode) {\n        throw new Error(\"List type requires tree argument to get leaves\");\n      }\n      length = this.tree_getLength(rootNode);\n    } else {\n      // Vectors don't need a rootNode to return length\n      length = this.tree_getLength(null);\n    }\n    const gindices = [];\n    if (composite_1.isCompositeType(this.elementType)) {\n      // Underlying elements exist one per chunk\n      // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk\n      const startIndex = persistent_merkle_tree_1.toGindex(this.depth, BigInt(0));\n      const endGindex = startIndex + BigInt(length);\n      const extendedStartIndex = persistent_merkle_tree_1.concatGindices([rootGindex, startIndex]);\n      if (this.elementType.fixedSize === null) {\n        if (!rootNode) {\n          /* istanbul ignore next - unreachable code */\n          throw new Error(\"Array of variable size requires tree argument to get leaves\");\n        }\n        // variable-length elements must pass the underlying subtrees to determine the length\n        for (let gindex = startIndex, extendedGindex = extendedStartIndex; gindex < endGindex; gindex++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex, persistent_merkle_tree_1.getNode(rootNode, gindex)));\n        }\n      } else {\n        for (let i = 0, extendedGindex = extendedStartIndex; i < length; i++, extendedGindex++) {\n          gindices.push(...this.elementType.tree_getLeafGindices(extendedGindex));\n        }\n      }\n    }\n    // Basic\n    else {\n      const chunkCount = Math.ceil(length / this.itemsPerChunk);\n      const startIndex = persistent_merkle_tree_1.concatGindices([rootGindex, persistent_merkle_tree_1.toGindex(this.depth, BigInt(0))]);\n      const endGindex = startIndex + BigInt(chunkCount);\n      for (let gindex = startIndex; gindex < endGindex; gindex++) {\n        gindices.push(gindex);\n      }\n    }\n    // include the length chunk\n    if (this.isList) {\n      gindices.push(persistent_merkle_tree_1.concatGindices([rootGindex, composite_1.LENGTH_GINDEX]));\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    // TODO: Do a better typesafe approach, all final classes of ArrayType implement ArrayProps\n    // There are multiple tests that cover this path for all clases\n    return arrayBasic_1.value_fromJsonArray(this.elementType, json, this);\n  }\n  toJson(value) {\n    return arrayBasic_1.value_toJsonArray(this.elementType, value, this);\n  }\n  clone(value) {\n    return arrayBasic_1.value_cloneArray(this.elementType, value);\n  }\n  equals(a, b) {\n    return arrayBasic_1.value_equals(this.elementType, a, b);\n  }\n}\nexports.ArrayType = ArrayType;","map":{"version":3,"names":["persistent_merkle_tree_1","require","composite_1","arrayBasic_1","ArrayType","CompositeType","constructor","elementType","defaultValue","value_defaultValueArray","defaultLen","getPropertyType","getPropertyGindex","prop","Error","chunkIdx","Math","floor","itemsPerChunk","toGindex","depth","BigInt","getIndexProperty","index","tree_getLeafGindices","rootGindex","rootNode","length","isList","tree_getLength","gindices","isCompositeType","startIndex","endGindex","extendedStartIndex","concatGindices","fixedSize","gindex","extendedGindex","push","getNode","i","chunkCount","ceil","LENGTH_GINDEX","fromJson","json","value_fromJsonArray","toJson","value","value_toJsonArray","clone","value_cloneArray","equals","a","b","value_equals","exports"],"sources":["../../src/type/array.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}