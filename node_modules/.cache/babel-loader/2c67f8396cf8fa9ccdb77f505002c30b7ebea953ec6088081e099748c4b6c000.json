{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitVectorType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitVector: ordered fixed-length collection of boolean values, with N bits\n * - Notation: `Bitvector[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitVectorType extends bitArray_2.BitArrayType {\n  constructor(lengthBits, opts) {\n    super();\n    this.lengthBits = lengthBits;\n    this.isList = false;\n    if (lengthBits === 0) throw Error(\"Vector length must be > 0\");\n    this.typeName = opts?.typeName ?? `BitVector[${lengthBits}]`;\n    this.chunkCount = Math.ceil(this.lengthBits / 8 / 32);\n    this.maxChunkCount = this.chunkCount;\n    this.depth = merkleize_1.maxChunksToDepth(this.chunkCount);\n    this.fixedSize = Math.ceil(this.lengthBits / 8);\n    this.minSize = this.fixedSize;\n    this.maxSize = this.fixedSize;\n    // To cache mask for trailing zero bits validation\n    this.zeroBitsMask = lengthBits % 8 === 0 ? 0 : 0xff & 0xff << lengthBits % 8;\n  }\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(BitVectorType, opts.typeName))(limitBits, opts);\n  }\n  defaultValue() {\n    return bitArray_1.BitArray.fromBitLen(this.lengthBits);\n  }\n  // Views: inherited from BitArrayType\n  // Serialization + deserialization\n  value_serializedSize() {\n    return this.fixedSize;\n  }\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value.uint8Array, offset);\n    return offset + this.fixedSize;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidLength(data.uint8Array, start, end);\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    return new bitArray_1.BitArray(Uint8Array.prototype.slice.call(data.uint8Array, start, end), this.lengthBits);\n  }\n  tree_serializedSize() {\n    return this.fixedSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.chunkCount);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, this.fixedSize, nodes);\n    return offset + this.fixedSize;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidLength(data.uint8Array, start, end);\n    return persistent_merkle_tree_1.packedRootsBytesToNode(this.depth, data.dataView, start, end);\n  }\n  tree_getByteLen() {\n    return this.fixedSize;\n  }\n  // Merkleization: inherited from BitArrayType\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from BitArrayType\n  // Deserializer helpers\n  assertValidLength(data, start, end) {\n    const size = end - start;\n    if (end - start !== this.fixedSize) {\n      throw Error(`Invalid BitVector size ${size} != ${this.fixedSize}`);\n    }\n    // If lengthBits is not aligned to bytes, ensure trailing bits are zeroed\n    if (\n    // If zeroBitsMask == 0, then the BitVector uses full bytes only\n    this.zeroBitsMask > 0 &&\n    // if the last byte is partial, retrieve it and use the cached mask to check if trailing bits are zeroed\n    (data[end - 1] & this.zeroBitsMask) > 0) {\n      throw Error(\"BitVector: nonzero bits past length\");\n    }\n  }\n}\nexports.BitVectorType = BitVectorType;","map":{"version":3,"names":["persistent_merkle_tree_1","require","merkleize_1","named_1","bitArray_1","bitArray_2","BitVectorType","BitArrayType","constructor","lengthBits","opts","isList","Error","typeName","chunkCount","Math","ceil","maxChunkCount","depth","maxChunksToDepth","fixedSize","minSize","maxSize","zeroBitsMask","named","limitBits","namedClass","defaultValue","BitArray","fromBitLen","value_serializedSize","value_serializeToBytes","output","offset","value","uint8Array","set","value_deserializeFromBytes","data","start","end","assertValidLength","Uint8Array","prototype","slice","call","tree_serializedSize","tree_serializeToBytes","node","nodes","getNodesAtDepth","packedNodeRootsToBytes","dataView","tree_deserializeFromBytes","packedRootsBytesToNode","tree_getByteLen","size","exports"],"sources":["../../src/type/bitVector.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}