{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayBasicTreeViewDU = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst abstract_1 = require(\"./abstract\");\nclass ArrayBasicTreeViewDU extends abstract_1.TreeViewDU {\n  constructor(type, _rootNode, cache) {\n    super();\n    this.type = type;\n    this._rootNode = _rootNode;\n    this.nodesChanged = new Set();\n    this.dirtyLength = false;\n    if (cache) {\n      this.nodes = cache.nodes;\n      this._length = cache.length;\n      this.nodesPopulated = cache.nodesPopulated;\n    } else {\n      this.nodes = [];\n      this._length = this.type.tree_getLength(_rootNode);\n      this.nodesPopulated = false;\n    }\n  }\n  /**\n   * Number of elements in the array. Equal to un-commited length of the array\n   */\n  get length() {\n    return this._length;\n  }\n  get node() {\n    return this._rootNode;\n  }\n  get cache() {\n    return {\n      nodes: this.nodes,\n      length: this._length,\n      nodesPopulated: this.nodesPopulated\n    };\n  }\n  /**\n   * Get element at `index`. Returns the Basic element type value directly\n   */\n  get(index) {\n    // First walk through the tree to get the root node for that index\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    let node = this.nodes[chunkIndex];\n    if (node === undefined) {\n      node = persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);\n      this.nodes[chunkIndex] = node;\n    }\n    return this.type.elementType.tree_getFromPackedNode(node, index);\n  }\n  /**\n   * Set Basic element type `value` at `index`\n   */\n  set(index, value) {\n    if (index >= this._length) {\n      throw Error(`Error setting index over length ${index} > ${this._length}`);\n    }\n    const chunkIndex = Math.floor(index / this.type.itemsPerChunk);\n    // Create new node if current leafNode is not dirty\n    let nodeChanged;\n    if (this.nodesChanged.has(chunkIndex)) {\n      // TODO: This assumes that node has already been populated\n      nodeChanged = this.nodes[chunkIndex];\n    } else {\n      const nodePrev = this.nodes[chunkIndex] ?? persistent_merkle_tree_1.getNodeAtDepth(this._rootNode, this.type.depth, chunkIndex);\n      nodeChanged = nodePrev.clone();\n      // Store the changed node in the nodes cache\n      this.nodes[chunkIndex] = nodeChanged;\n      this.nodesChanged.add(chunkIndex);\n    }\n    this.type.elementType.tree_setToPackedNode(nodeChanged, index, value);\n  }\n  /**\n   * Get all values of this array as Basic element type values, from index zero to `this.length - 1`\n   */\n  getAll() {\n    if (!this.nodesPopulated) {\n      const nodesPrev = this.nodes;\n      const chunksNode = this.type.tree_getChunksNode(this.node);\n      const chunkCount = Math.ceil(this._length / this.type.itemsPerChunk);\n      this.nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.type.chunkDepth, 0, chunkCount);\n      // Re-apply changed nodes\n      for (const index of this.nodesChanged) {\n        this.nodes[index] = nodesPrev[index];\n      }\n      this.nodesPopulated = true;\n    }\n    const values = new Array(this._length);\n    const itemsPerChunk = this.type.itemsPerChunk; // Prevent many access in for loop below\n    const lenFullNodes = Math.floor(this._length / itemsPerChunk);\n    const remainder = this._length % itemsPerChunk;\n    // TODO Optimize: caching the variables used in the loop above it\n    for (let n = 0; n < lenFullNodes; n++) {\n      const leafNode = this.nodes[n];\n      // TODO: Implement add a fast bulk packed element reader in the elementType\n      // ```\n      // abstract getValuesFromPackedNode(leafNode: LeafNode, output: V[], indexOffset: number): void;\n      // ```\n      // if performance here is a problem\n      for (let i = 0; i < itemsPerChunk; i++) {\n        values[n * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    if (remainder > 0) {\n      const leafNode = this.nodes[lenFullNodes];\n      for (let i = 0; i < remainder; i++) {\n        values[lenFullNodes * itemsPerChunk + i] = this.type.elementType.tree_getFromPackedNode(leafNode, i);\n      }\n    }\n    return values;\n  }\n  commit() {\n    if (this.nodesChanged.size === 0) {\n      return;\n    }\n    // Numerical sort ascending\n    const indexes = Array.from(this.nodesChanged.keys()).sort((a, b) => a - b);\n    const nodes = new Array(indexes.length);\n    for (let i = 0; i < indexes.length; i++) {\n      nodes[i] = this.nodes[indexes[i]];\n    }\n    const chunksNode = this.type.tree_getChunksNode(this._rootNode);\n    // TODO: Ensure fast setNodesAtDepth() method is correct\n    const newChunksNode = persistent_merkle_tree_1.setNodesAtDepth(chunksNode, this.type.chunkDepth, indexes, nodes);\n    this._rootNode = this.type.tree_setChunksNode(this._rootNode, newChunksNode, this.dirtyLength ? this._length : undefined);\n    this.nodesChanged.clear();\n    this.dirtyLength = false;\n  }\n  clearCache() {\n    this.nodes = [];\n    this.nodesPopulated = false;\n    // Must clear nodesChanged, otherwise a subsequent commit call will break, because it assumes a node is there\n    this.nodesChanged.clear();\n    // Reset cached length only if it has been mutated\n    if (this.dirtyLength) {\n      this._length = this.type.tree_getLength(this._rootNode);\n      this.dirtyLength = false;\n    }\n  }\n}\nexports.ArrayBasicTreeViewDU = ArrayBasicTreeViewDU;","map":{"version":3,"names":["persistent_merkle_tree_1","require","abstract_1","ArrayBasicTreeViewDU","TreeViewDU","constructor","type","_rootNode","cache","nodesChanged","Set","dirtyLength","nodes","_length","length","nodesPopulated","tree_getLength","node","get","index","chunkIndex","Math","floor","itemsPerChunk","undefined","getNodeAtDepth","depth","elementType","tree_getFromPackedNode","set","value","Error","nodeChanged","has","nodePrev","clone","add","tree_setToPackedNode","getAll","nodesPrev","chunksNode","tree_getChunksNode","chunkCount","ceil","getNodesAtDepth","chunkDepth","values","Array","lenFullNodes","remainder","n","leafNode","i","commit","size","indexes","from","keys","sort","a","b","newChunksNode","setNodesAtDepth","tree_setChunksNode","clear","clearCache","exports"],"sources":["../../src/viewDU/arrayBasic.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}