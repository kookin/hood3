{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BooleanType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst named_1 = require(\"../util/named\");\nconst basic_1 = require(\"./basic\");\n/**\n * Boolean: True or False\n * - Notation: `boolean`\n */\nclass BooleanType extends basic_1.BasicType {\n  constructor(opts) {\n    super();\n    this.byteLength = 1;\n    this.itemsPerChunk = 32;\n    this.fixedSize = 1;\n    this.minSize = 1;\n    this.maxSize = 1;\n    this.typeName = opts?.typeName ?? \"boolean\";\n  }\n  static named(opts) {\n    return new (named_1.namedClass(BooleanType, opts.typeName))(opts);\n  }\n  defaultValue() {\n    return false;\n  }\n  // Serialization + deserialization\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array[offset] = value ? 1 : 0;\n    return offset + 1;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    switch (data.uint8Array[start]) {\n      case 1:\n        return true;\n      case 0:\n        return false;\n      default:\n        throw new Error(`Boolean: invalid value: ${data.uint8Array[start]}`);\n    }\n  }\n  tree_serializeToBytes(output, offset, node) {\n    // TODO: Assumes LeafNode has 4 byte uints are primary unit\n    output.uint8Array[offset] = node.getUint(4, 0);\n    return offset + 1;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    this.assertValidSize(end - start);\n    const value = data.uint8Array[start];\n    if (value > 1) {\n      throw Error(`Boolean: invalid value ${value}`);\n    }\n    return persistent_merkle_tree_1.LeafNode.fromUint32(value);\n  }\n  // Fast tree opts\n  tree_getFromNode(leafNode) {\n    return leafNode.getUint(4, 0) === 1;\n  }\n  tree_setToNode(leafNode, value) {\n    leafNode.setUint(4, 0, value ? 1 : 0);\n  }\n  tree_getFromPackedNode(leafNode, index) {\n    const offsetBytes = index % this.itemsPerChunk;\n    return leafNode.getUint(1, offsetBytes) !== 0;\n  }\n  tree_setToPackedNode(leafNode, index, value) {\n    const offsetBytes = index % this.itemsPerChunk;\n    leafNode.setUint(1, offsetBytes, value ? 1 : 0);\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"boolean\") {\n      throw Error(`JSON invalid type ${typeof json} expected boolean`);\n    }\n    return json;\n  }\n  toJson(value) {\n    return value;\n  }\n}\nexports.BooleanType = BooleanType;","map":{"version":3,"names":["persistent_merkle_tree_1","require","named_1","basic_1","BooleanType","BasicType","constructor","opts","byteLength","itemsPerChunk","fixedSize","minSize","maxSize","typeName","named","namedClass","defaultValue","value_serializeToBytes","output","offset","value","uint8Array","value_deserializeFromBytes","data","start","end","assertValidSize","Error","tree_serializeToBytes","node","getUint","tree_deserializeFromBytes","LeafNode","fromUint32","tree_getFromNode","leafNode","tree_setToNode","setUint","tree_getFromPackedNode","index","offsetBytes","tree_setToPackedNode","fromJson","json","toJson","exports"],"sources":["../../src/type/boolean.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}