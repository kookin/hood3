{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FountainDecoderPart = void 0;\nconst utils_1 = require(\"./utils\");\nconst fountainUtils_1 = require(\"./fountainUtils\");\nconst errors_1 = require(\"./errors\");\nclass FountainDecoderPart {\n  constructor(_indexes, _fragment) {\n    this._indexes = _indexes;\n    this._fragment = _fragment;\n  }\n  get indexes() {\n    return this._indexes;\n  }\n  get fragment() {\n    return this._fragment;\n  }\n  static fromEncoderPart(encoderPart) {\n    const indexes = fountainUtils_1.chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n    return new FountainDecoderPart(indexes, fragment);\n  }\n  isSimple() {\n    return this.indexes.length === 1;\n  }\n}\nexports.FountainDecoderPart = FountainDecoderPart;\nclass FountainDecoder {\n  constructor() {\n    this.result = undefined;\n    this.expectedMessageLength = 0;\n    this.expectedChecksum = 0;\n    this.expectedFragmentLength = 0;\n    this.processedPartsCount = 0;\n    this.expectedPartIndexes = [];\n    this.lastPartIndexes = [];\n    this.queuedParts = [];\n    this.receivedPartIndexes = [];\n    this.mixedParts = [];\n    this.simpleParts = [];\n  }\n  validatePart(part) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)].forEach((_, index) => this.expectedPartIndexes.push(index));\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    } else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n    // This part should be processed\n    return true;\n  }\n  reducePartByPart(a, b) {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (utils_1.arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = utils_1.setDifference(a.indexes, b.indexes);\n      const newFragment = utils_1.bufferXOR(a.fragment, b.fragment);\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n  reduceMixedBy(part) {\n    const newMixed = [];\n    this.mixedParts.map(_ref => {\n      let {\n        value: mixedPart\n      } = _ref;\n      return this.reducePartByPart(mixedPart, part);\n    }).forEach(reducedPart => {\n      if (reducedPart.isSimple()) {\n        this.queuedParts.push(reducedPart);\n      } else {\n        newMixed.push({\n          key: reducedPart.indexes,\n          value: reducedPart\n        });\n      }\n    });\n    this.mixedParts = newMixed;\n  }\n  processSimplePart(part) {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0];\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n    this.simpleParts.push({\n      key: part.indexes,\n      value: part\n    });\n    this.receivedPartIndexes.push(fragmentIndex);\n    // If we've received all the parts\n    if (utils_1.arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts.map(_ref2 => {\n        let {\n          value\n        } = _ref2;\n        return value;\n      }).sort((a, b) => a.indexes[0] - b.indexes[0]);\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength);\n      const checksum = utils_1.getCRC(message);\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new errors_1.InvalidChecksumError();\n      }\n    } else {\n      this.reduceMixedBy(part);\n    }\n  }\n  processMixedPart(part) {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(_ref3 => {\n      let {\n        key: indexes\n      } = _ref3;\n      return utils_1.arraysEqual(indexes, part.indexes);\n    })) {\n      return;\n    }\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, _ref4) => {\n      let {\n        value: p\n      } = _ref4;\n      return this.reducePartByPart(acc, p);\n    }, part);\n    p2 = this.mixedParts.reduce((acc, _ref5) => {\n      let {\n        value: p\n      } = _ref5;\n      return this.reducePartByPart(acc, p);\n    }, p2);\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n      this.mixedParts.push({\n        key: p2.indexes,\n        value: p2\n      });\n    }\n  }\n  processQueuedItem() {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n    const part = this.queuedParts.shift();\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n  receivePart(encoderPart) {\n    if (this.isComplete()) {\n      return false;\n    }\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    }\n    ;\n    this.processedPartsCount += 1;\n    return true;\n  }\n  isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n  isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n  resultMessage() {\n    return this.isSuccess() ? this.result : Buffer.from([]);\n  }\n  isFailure() {\n    return this.error !== undefined;\n  }\n  resultError() {\n    return this.error ? this.error.message : '';\n  }\n  expectedPartCount() {\n    return this.expectedPartIndexes.length;\n  }\n  getExpectedPartIndexes() {\n    return [...this.expectedPartIndexes];\n  }\n  getReceivedPartIndexes() {\n    return [...this.receivedPartIndexes];\n  }\n  getLastPartIndexes() {\n    return [...this.lastPartIndexes];\n  }\n  estimatedPercentComplete() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n  getProgress() {\n    if (this.isComplete()) {\n      return 1;\n    }\n    const expectedPartCount = this.expectedPartCount();\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\nexports.default = FountainDecoder;\nFountainDecoder.joinFragments = (fragments, messageLength) => {\n  return Buffer.concat(fragments).slice(0, messageLength);\n};","map":{"version":3,"names":["utils_1","require","fountainUtils_1","errors_1","FountainDecoderPart","constructor","_indexes","_fragment","indexes","fragment","fromEncoderPart","encoderPart","chooseFragments","seqNum","seqLength","checksum","isSimple","length","exports","FountainDecoder","result","undefined","expectedMessageLength","expectedChecksum","expectedFragmentLength","processedPartsCount","expectedPartIndexes","lastPartIndexes","queuedParts","receivedPartIndexes","mixedParts","simpleParts","validatePart","part","Array","forEach","_","index","push","messageLength","reducePartByPart","a","b","arrayContains","newIndexes","setDifference","newFragment","bufferXOR","reduceMixedBy","newMixed","map","_ref","value","mixedPart","reducedPart","key","processSimplePart","fragmentIndex","includes","arraysEqual","sortedParts","_ref2","sort","message","joinFragments","getCRC","error","InvalidChecksumError","processMixedPart","some","_ref3","p2","reduce","acc","_ref4","p","_ref5","processQueuedItem","shift","receivePart","isComplete","decoderPart","Boolean","isSuccess","resultMessage","Buffer","from","isFailure","resultError","expectedPartCount","getExpectedPartIndexes","getReceivedPartIndexes","getLastPartIndexes","estimatedPercentComplete","Math","min","getProgress","default","fragments","concat","slice"],"sources":["/hood3/node_modules/@ngraveio/bc-ur/src/fountainDecoder.ts"],"sourcesContent":["import { arrayContains, arraysEqual, bufferXOR, getCRC, setDifference, split } from \"./utils\";\nimport { chooseFragments } from \"./fountainUtils\";\nimport { FountainEncoderPart } from \"./fountainEncoder\";\nimport { InvalidChecksumError } from \"./errors\";\n\nexport class FountainDecoderPart {\n  constructor(\n    private _indexes: number[],\n    private _fragment: Buffer\n  ) { }\n\n  get indexes() { return this._indexes; }\n  get fragment() { return this._fragment; }\n\n  public static fromEncoderPart(encoderPart: FountainEncoderPart) {\n    const indexes = chooseFragments(encoderPart.seqNum, encoderPart.seqLength, encoderPart.checksum);\n    const fragment = encoderPart.fragment;\n\n    return new FountainDecoderPart(indexes, fragment);\n  }\n\n  public isSimple() {\n    return this.indexes.length === 1;\n  }\n}\n\ntype PartIndexes = number[];\ninterface PartDict {\n  key: PartIndexes;\n  value: FountainDecoderPart;\n}\n\nexport default class FountainDecoder {\n  private error: Error | undefined;\n  private result: Buffer | undefined = undefined;\n  private expectedMessageLength: number = 0;\n  private expectedChecksum: number = 0;\n  private expectedFragmentLength: number = 0;\n  private processedPartsCount: number = 0;\n  private expectedPartIndexes: PartIndexes = [];\n  private lastPartIndexes: PartIndexes = [];\n  private queuedParts: FountainDecoderPart[] = [];\n  private receivedPartIndexes: PartIndexes = [];\n  private mixedParts: PartDict[] = [];\n  private simpleParts: PartDict[] = [];\n\n\n  private validatePart(part: FountainEncoderPart) {\n    // If this is the first part we've seen\n    if (this.expectedPartIndexes.length === 0) {\n      // Record the things that all the other parts we see will have to match to be valid.\n      [...new Array(part.seqLength)]\n        .forEach((_, index) => this.expectedPartIndexes.push(index));\n\n      this.expectedMessageLength = part.messageLength;\n      this.expectedChecksum = part.checksum;\n      this.expectedFragmentLength = part.fragment.length;\n    }\n    else {\n      // If this part's values don't match the first part's values, throw away the part\n      if (this.expectedPartIndexes.length !== part.seqLength) {\n        return false;\n      }\n      if (this.expectedMessageLength !== part.messageLength) {\n        return false;\n      }\n      if (this.expectedChecksum !== part.checksum) {\n        return false;\n      }\n      if (this.expectedFragmentLength !== part.fragment.length) {\n        return false;\n      }\n    }\n\n    // This part should be processed\n    return true;\n  }\n\n  private reducePartByPart(a: FountainDecoderPart, b: FountainDecoderPart): FountainDecoderPart {\n    // If the fragments mixed into `b` are a strict (proper) subset of those in `a`...\n    if (arrayContains(a.indexes, b.indexes)) {\n      const newIndexes = setDifference(a.indexes, b.indexes);\n      const newFragment = bufferXOR(a.fragment, b.fragment);\n\n      return new FountainDecoderPart(newIndexes, newFragment);\n    } else {\n      // `a` is not reducable by `b`, so return a\n      return a;\n    }\n  }\n\n  private reduceMixedBy(part: FountainDecoderPart): void {\n    const newMixed: PartDict[] = [];\n\n    this.mixedParts\n      .map(({ value: mixedPart }) => this.reducePartByPart(mixedPart, part))\n      .forEach(reducedPart => {\n        if (reducedPart.isSimple()) {\n          this.queuedParts.push(reducedPart)\n        } else {\n          newMixed.push({ key: reducedPart.indexes, value: reducedPart })\n        }\n      })\n\n    this.mixedParts = newMixed;\n  }\n\n  private processSimplePart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    const fragmentIndex = part.indexes[0]\n\n    if (this.receivedPartIndexes.includes(fragmentIndex)) {\n      return;\n    }\n\n    this.simpleParts.push({ key: part.indexes, value: part });\n    this.receivedPartIndexes.push(fragmentIndex);\n\n    // If we've received all the parts\n    if (arraysEqual(this.receivedPartIndexes, this.expectedPartIndexes)) {\n      // Reassemble the message from its fragments\n      const sortedParts = this.simpleParts\n        .map(({ value }) => value)\n        .sort((a, b) => (a.indexes[0] - b.indexes[0]))\n      const message = FountainDecoder.joinFragments(sortedParts.map(part => part.fragment), this.expectedMessageLength)\n      const checksum = getCRC(message);\n\n      if (checksum === this.expectedChecksum) {\n        this.result = message;\n      } else {\n        this.error = new InvalidChecksumError();\n      }\n    }\n    else {\n      this.reduceMixedBy(part);\n    }\n  }\n\n  private processMixedPart(part: FountainDecoderPart): void {\n    // Don't process duplicate parts\n    if (this.mixedParts.some(({ key: indexes }) => arraysEqual(indexes, part.indexes))) {\n      return;\n    }\n\n    // Reduce this part by all the others\n    let p2 = this.simpleParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), part)\n    p2 = this.mixedParts.reduce((acc, { value: p }) => this.reducePartByPart(acc, p), p2)\n\n    // If the part is now simple\n    if (p2.isSimple()) {\n      // Add it to the queue\n      this.queuedParts.push(p2);\n    } else {\n      this.reduceMixedBy(p2);\n\n      this.mixedParts.push({ key: p2.indexes, value: p2 });\n    }\n  }\n\n  private processQueuedItem(): void {\n    if (this.queuedParts.length === 0) {\n      return;\n    }\n\n    const part = this.queuedParts.shift()!;\n\n    if (part.isSimple()) {\n      this.processSimplePart(part);\n    } else {\n      this.processMixedPart(part);\n    }\n  }\n\n  public static joinFragments = (fragments: Buffer[], messageLength: number) => {\n    return Buffer.concat(fragments).slice(0, messageLength)\n  }\n\n  public receivePart(encoderPart: FountainEncoderPart): boolean {\n    if (this.isComplete()) {\n      return false;\n    }\n\n    if (!this.validatePart(encoderPart)) {\n      return false;\n    }\n\n    const decoderPart = FountainDecoderPart.fromEncoderPart(encoderPart);\n\n    this.lastPartIndexes = decoderPart.indexes;\n    this.queuedParts.push(decoderPart);\n\n    while (!this.isComplete() && this.queuedParts.length > 0) {\n      this.processQueuedItem();\n    };\n\n    this.processedPartsCount += 1;\n\n    return true;\n  }\n\n  public isComplete() {\n    return Boolean(this.result !== undefined && this.result.length > 0);\n  }\n\n  public isSuccess() {\n    return Boolean(this.error === undefined && this.isComplete());\n  }\n\n  public resultMessage(): Buffer {\n    return this.isSuccess() ? this.result! : Buffer.from([]);\n  }\n\n  public isFailure() {\n    return this.error !== undefined;\n  }\n\n  public resultError() {\n    return this.error ? this.error.message : '';\n  }\n\n  public expectedPartCount(): number {\n    return this.expectedPartIndexes.length;\n  }\n\n  public getExpectedPartIndexes(): PartIndexes {\n    return [...this.expectedPartIndexes]\n  }\n\n  public getReceivedPartIndexes(): PartIndexes {\n    return [...this.receivedPartIndexes]\n  }\n\n  public getLastPartIndexes(): PartIndexes {\n    return [...this.lastPartIndexes]\n  }\n\n  public estimatedPercentComplete(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    // We multiply the expectedPartCount by `1.75` as a way to compensate for the facet\n    // that `this.processedPartsCount` also tracks the duplicate parts that have been\n    // processeed.\n    return Math.min(0.99, this.processedPartsCount / (expectedPartCount * 1.75));\n  }\n\n  public getProgress(): number {\n    if (this.isComplete()) {\n      return 1;\n    }\n\n    const expectedPartCount = this.expectedPartCount();\n\n    if (expectedPartCount === 0) {\n      return 0;\n    }\n\n    return this.receivedPartIndexes.length / expectedPartCount;\n  }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}