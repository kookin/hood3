{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;\nfunction bitIndexBigInt(v) {\n  return v.toString(2).length - 1;\n}\nexports.bitIndexBigInt = bitIndexBigInt;\nfunction toGindex(depth, index) {\n  const anchor = BigInt(1) << BigInt(depth);\n  if (index >= anchor) {\n    throw new Error(`index ${index} too large for depth ${depth}`);\n  }\n  return anchor | index;\n}\nexports.toGindex = toGindex;\nfunction toGindexBitstring(depth, index) {\n  const str = index ? Number(index).toString(2) : \"\";\n  if (str.length > depth) {\n    throw new Error(\"index too large for depth\");\n  } else {\n    return \"1\" + str.padStart(depth, \"0\");\n  }\n}\nexports.toGindexBitstring = toGindexBitstring;\nfunction convertGindexToBitstring(gindex) {\n  if (typeof gindex === \"string\") {\n    if (gindex.length === 0) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    return gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    return gindex.toString(2);\n  }\n}\nexports.convertGindexToBitstring = convertGindexToBitstring;\n// Get the depth (root starting at 0) necessary to cover a subtree of `count` elements.\n// (in out): (0 0), (1 0), (2 1), (3 2), (4 2), (5 3), (6 3), (7 3), (8 3), (9 4)\nfunction countToDepth(count) {\n  if (count <= 1) {\n    return 0;\n  }\n  return (count - BigInt(1)).toString(2).length;\n}\nexports.countToDepth = countToDepth;\n/**\n * Iterate through Gindexes at a certain depth\n */\nfunction iterateAtDepth(depth, startIndex, count) {\n  const anchor = BigInt(1) << BigInt(depth);\n  if (startIndex + count > anchor) {\n    throw new Error(\"Too large for depth\");\n  }\n  let i = toGindex(depth, startIndex);\n  const last = i + count;\n  return {\n    [Symbol.iterator]() {\n      return {\n        next() {\n          if (i < last) {\n            const value = i;\n            i++;\n            return {\n              done: false,\n              value\n            };\n          } else {\n            return {\n              done: true,\n              value: undefined\n            };\n          }\n        }\n      };\n    }\n  };\n}\nexports.iterateAtDepth = iterateAtDepth;\n/**\n * Return Gindexes at a certain depth\n */\nfunction getGindicesAtDepth(depth, startIndex, count) {\n  const anchor = BigInt(1) << BigInt(depth);\n  if (startIndex + count > anchor) {\n    throw new Error(\"Too large for depth\");\n  }\n  let gindex = toGindex(depth, BigInt(startIndex));\n  const gindices = [];\n  for (let i = 0; i < count; i++) {\n    gindices.push(gindex++);\n  }\n  return gindices;\n}\nexports.getGindicesAtDepth = getGindicesAtDepth;\nconst ERR_INVALID_GINDEX = \"Invalid gindex\";\nfunction gindexIterator(gindex) {\n  let bitstring;\n  if (typeof gindex === \"string\") {\n    if (!gindex.length) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex.toString(2);\n  }\n  let i = 1;\n  const next = () => {\n    if (i === bitstring.length) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const bit = Number(bitstring[i]);\n    i++;\n    return {\n      done: false,\n      value: bit\n    };\n  };\n  return {\n    [Symbol.iterator]() {\n      return {\n        next\n      };\n    },\n    remainingBitLength() {\n      return bitstring.length - i;\n    }\n  };\n}\nexports.gindexIterator = gindexIterator;\nfunction getGindexBits(gindex) {\n  let bitstring;\n  if (typeof gindex === \"string\") {\n    if (!gindex.length) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex;\n  } else {\n    if (gindex < 1) {\n      throw new Error(ERR_INVALID_GINDEX);\n    }\n    bitstring = gindex.toString(2);\n  }\n  const bits = [];\n  for (let i = 1; i < bitstring.length; i++) {\n    bits.push(Number(bitstring[i]));\n  }\n  return bits;\n}\nexports.getGindexBits = getGindexBits;\n/**\n * Concatenate Generalized Indices\n * Given generalized indices i1 for A -> B, i2 for B -> C .... i_n for Y -> Z, returns\n * the generalized index for A -> Z.\n */\nfunction concatGindices(gindices) {\n  return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), \"0b1\"));\n}\nexports.concatGindices = concatGindices;\nfunction gindexSibling(gindex) {\n  return gindex ^ BigInt(1);\n}\nexports.gindexSibling = gindexSibling;\nfunction gindexParent(gindex) {\n  return gindex / BigInt(2);\n}\nexports.gindexParent = gindexParent;\nfunction gindexChild(gindex, rightChild) {\n  return gindex * BigInt(2) + BigInt(rightChild);\n}\nexports.gindexChild = gindexChild;","map":{"version":3,"names":["Object","defineProperty","exports","value","gindexChild","gindexParent","gindexSibling","concatGindices","getGindexBits","gindexIterator","getGindicesAtDepth","iterateAtDepth","countToDepth","convertGindexToBitstring","toGindexBitstring","toGindex","bitIndexBigInt","v","toString","length","depth","index","anchor","BigInt","Error","str","Number","padStart","gindex","ERR_INVALID_GINDEX","count","startIndex","i","last","Symbol","iterator","next","done","undefined","gindices","push","bitstring","bit","remainingBitLength","bits","reduce","acc","slice","rightChild"],"sources":["/hood3/node_modules/@chainsafe/persistent-merkle-tree/lib/gindex.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.getGindexBits = exports.gindexIterator = exports.getGindicesAtDepth = exports.iterateAtDepth = exports.countToDepth = exports.convertGindexToBitstring = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;\nfunction bitIndexBigInt(v) {\n    return v.toString(2).length - 1;\n}\nexports.bitIndexBigInt = bitIndexBigInt;\nfunction toGindex(depth, index) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (index >= anchor) {\n        throw new Error(`index ${index} too large for depth ${depth}`);\n    }\n    return anchor | index;\n}\nexports.toGindex = toGindex;\nfunction toGindexBitstring(depth, index) {\n    const str = index ? Number(index).toString(2) : \"\";\n    if (str.length > depth) {\n        throw new Error(\"index too large for depth\");\n    }\n    else {\n        return \"1\" + str.padStart(depth, \"0\");\n    }\n}\nexports.toGindexBitstring = toGindexBitstring;\nfunction convertGindexToBitstring(gindex) {\n    if (typeof gindex === \"string\") {\n        if (gindex.length === 0) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        return gindex;\n    }\n    else {\n        if (gindex < 1) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        return gindex.toString(2);\n    }\n}\nexports.convertGindexToBitstring = convertGindexToBitstring;\n// Get the depth (root starting at 0) necessary to cover a subtree of `count` elements.\n// (in out): (0 0), (1 0), (2 1), (3 2), (4 2), (5 3), (6 3), (7 3), (8 3), (9 4)\nfunction countToDepth(count) {\n    if (count <= 1) {\n        return 0;\n    }\n    return (count - BigInt(1)).toString(2).length;\n}\nexports.countToDepth = countToDepth;\n/**\n * Iterate through Gindexes at a certain depth\n */\nfunction iterateAtDepth(depth, startIndex, count) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (startIndex + count > anchor) {\n        throw new Error(\"Too large for depth\");\n    }\n    let i = toGindex(depth, startIndex);\n    const last = i + count;\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    if (i < last) {\n                        const value = i;\n                        i++;\n                        return { done: false, value };\n                    }\n                    else {\n                        return { done: true, value: undefined };\n                    }\n                },\n            };\n        },\n    };\n}\nexports.iterateAtDepth = iterateAtDepth;\n/**\n * Return Gindexes at a certain depth\n */\nfunction getGindicesAtDepth(depth, startIndex, count) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (startIndex + count > anchor) {\n        throw new Error(\"Too large for depth\");\n    }\n    let gindex = toGindex(depth, BigInt(startIndex));\n    const gindices = [];\n    for (let i = 0; i < count; i++) {\n        gindices.push(gindex++);\n    }\n    return gindices;\n}\nexports.getGindicesAtDepth = getGindicesAtDepth;\nconst ERR_INVALID_GINDEX = \"Invalid gindex\";\nfunction gindexIterator(gindex) {\n    let bitstring;\n    if (typeof gindex === \"string\") {\n        if (!gindex.length) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex;\n    }\n    else {\n        if (gindex < 1) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex.toString(2);\n    }\n    let i = 1;\n    const next = () => {\n        if (i === bitstring.length) {\n            return { done: true, value: undefined };\n        }\n        const bit = Number(bitstring[i]);\n        i++;\n        return { done: false, value: bit };\n    };\n    return {\n        [Symbol.iterator]() {\n            return { next };\n        },\n        remainingBitLength() {\n            return bitstring.length - i;\n        },\n    };\n}\nexports.gindexIterator = gindexIterator;\nfunction getGindexBits(gindex) {\n    let bitstring;\n    if (typeof gindex === \"string\") {\n        if (!gindex.length) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex;\n    }\n    else {\n        if (gindex < 1) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex.toString(2);\n    }\n    const bits = [];\n    for (let i = 1; i < bitstring.length; i++) {\n        bits.push(Number(bitstring[i]));\n    }\n    return bits;\n}\nexports.getGindexBits = getGindexBits;\n/**\n * Concatenate Generalized Indices\n * Given generalized indices i1 for A -> B, i2 for B -> C .... i_n for Y -> Z, returns\n * the generalized index for A -> Z.\n */\nfunction concatGindices(gindices) {\n    return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), \"0b1\"));\n}\nexports.concatGindices = concatGindices;\nfunction gindexSibling(gindex) {\n    return gindex ^ BigInt(1);\n}\nexports.gindexSibling = gindexSibling;\nfunction gindexParent(gindex) {\n    return gindex / BigInt(2);\n}\nexports.gindexParent = gindexParent;\nfunction gindexChild(gindex, rightChild) {\n    return gindex * BigInt(2) + BigInt(rightChild);\n}\nexports.gindexChild = gindexChild;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAGF,OAAO,CAACG,YAAY,GAAGH,OAAO,CAACI,aAAa,GAAGJ,OAAO,CAACK,cAAc,GAAGL,OAAO,CAACM,aAAa,GAAGN,OAAO,CAACO,cAAc,GAAGP,OAAO,CAACQ,kBAAkB,GAAGR,OAAO,CAACS,cAAc,GAAGT,OAAO,CAACU,YAAY,GAAGV,OAAO,CAACW,wBAAwB,GAAGX,OAAO,CAACY,iBAAiB,GAAGZ,OAAO,CAACa,QAAQ,GAAGb,OAAO,CAACc,cAAc,GAAG,KAAK,CAAC;AAC7U,SAASA,cAAcA,CAACC,CAAC,EAAE;EACvB,OAAOA,CAAC,CAACC,QAAQ,CAAC,CAAC,CAAC,CAACC,MAAM,GAAG,CAAC;AACnC;AACAjB,OAAO,CAACc,cAAc,GAAGA,cAAc;AACvC,SAASD,QAAQA,CAACK,KAAK,EAAEC,KAAK,EAAE;EAC5B,MAAMC,MAAM,GAAGC,MAAM,CAAC,CAAC,CAAC,IAAIA,MAAM,CAACH,KAAK,CAAC;EACzC,IAAIC,KAAK,IAAIC,MAAM,EAAE;IACjB,MAAM,IAAIE,KAAK,CAAE,SAAQH,KAAM,wBAAuBD,KAAM,EAAC,CAAC;EAClE;EACA,OAAOE,MAAM,GAAGD,KAAK;AACzB;AACAnB,OAAO,CAACa,QAAQ,GAAGA,QAAQ;AAC3B,SAASD,iBAAiBA,CAACM,KAAK,EAAEC,KAAK,EAAE;EACrC,MAAMI,GAAG,GAAGJ,KAAK,GAAGK,MAAM,CAACL,KAAK,CAAC,CAACH,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE;EAClD,IAAIO,GAAG,CAACN,MAAM,GAAGC,KAAK,EAAE;IACpB,MAAM,IAAII,KAAK,CAAC,2BAA2B,CAAC;EAChD,CAAC,MACI;IACD,OAAO,GAAG,GAAGC,GAAG,CAACE,QAAQ,CAACP,KAAK,EAAE,GAAG,CAAC;EACzC;AACJ;AACAlB,OAAO,CAACY,iBAAiB,GAAGA,iBAAiB;AAC7C,SAASD,wBAAwBA,CAACe,MAAM,EAAE;EACtC,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC5B,IAAIA,MAAM,CAACT,MAAM,KAAK,CAAC,EAAE;MACrB,MAAM,IAAIK,KAAK,CAACK,kBAAkB,CAAC;IACvC;IACA,OAAOD,MAAM;EACjB,CAAC,MACI;IACD,IAAIA,MAAM,GAAG,CAAC,EAAE;MACZ,MAAM,IAAIJ,KAAK,CAACK,kBAAkB,CAAC;IACvC;IACA,OAAOD,MAAM,CAACV,QAAQ,CAAC,CAAC,CAAC;EAC7B;AACJ;AACAhB,OAAO,CAACW,wBAAwB,GAAGA,wBAAwB;AAC3D;AACA;AACA,SAASD,YAAYA,CAACkB,KAAK,EAAE;EACzB,IAAIA,KAAK,IAAI,CAAC,EAAE;IACZ,OAAO,CAAC;EACZ;EACA,OAAO,CAACA,KAAK,GAAGP,MAAM,CAAC,CAAC,CAAC,EAAEL,QAAQ,CAAC,CAAC,CAAC,CAACC,MAAM;AACjD;AACAjB,OAAO,CAACU,YAAY,GAAGA,YAAY;AACnC;AACA;AACA;AACA,SAASD,cAAcA,CAACS,KAAK,EAAEW,UAAU,EAAED,KAAK,EAAE;EAC9C,MAAMR,MAAM,GAAGC,MAAM,CAAC,CAAC,CAAC,IAAIA,MAAM,CAACH,KAAK,CAAC;EACzC,IAAIW,UAAU,GAAGD,KAAK,GAAGR,MAAM,EAAE;IAC7B,MAAM,IAAIE,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACA,IAAIQ,CAAC,GAAGjB,QAAQ,CAACK,KAAK,EAAEW,UAAU,CAAC;EACnC,MAAME,IAAI,GAAGD,CAAC,GAAGF,KAAK;EACtB,OAAO;IACH,CAACI,MAAM,CAACC,QAAQ,IAAI;MAChB,OAAO;QACHC,IAAIA,CAAA,EAAG;UACH,IAAIJ,CAAC,GAAGC,IAAI,EAAE;YACV,MAAM9B,KAAK,GAAG6B,CAAC;YACfA,CAAC,EAAE;YACH,OAAO;cAAEK,IAAI,EAAE,KAAK;cAAElC;YAAM,CAAC;UACjC,CAAC,MACI;YACD,OAAO;cAAEkC,IAAI,EAAE,IAAI;cAAElC,KAAK,EAAEmC;YAAU,CAAC;UAC3C;QACJ;MACJ,CAAC;IACL;EACJ,CAAC;AACL;AACApC,OAAO,CAACS,cAAc,GAAGA,cAAc;AACvC;AACA;AACA;AACA,SAASD,kBAAkBA,CAACU,KAAK,EAAEW,UAAU,EAAED,KAAK,EAAE;EAClD,MAAMR,MAAM,GAAGC,MAAM,CAAC,CAAC,CAAC,IAAIA,MAAM,CAACH,KAAK,CAAC;EACzC,IAAIW,UAAU,GAAGD,KAAK,GAAGR,MAAM,EAAE;IAC7B,MAAM,IAAIE,KAAK,CAAC,qBAAqB,CAAC;EAC1C;EACA,IAAII,MAAM,GAAGb,QAAQ,CAACK,KAAK,EAAEG,MAAM,CAACQ,UAAU,CAAC,CAAC;EAChD,MAAMQ,QAAQ,GAAG,EAAE;EACnB,KAAK,IAAIP,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,EAAEE,CAAC,EAAE,EAAE;IAC5BO,QAAQ,CAACC,IAAI,CAACZ,MAAM,EAAE,CAAC;EAC3B;EACA,OAAOW,QAAQ;AACnB;AACArC,OAAO,CAACQ,kBAAkB,GAAGA,kBAAkB;AAC/C,MAAMmB,kBAAkB,GAAG,gBAAgB;AAC3C,SAASpB,cAAcA,CAACmB,MAAM,EAAE;EAC5B,IAAIa,SAAS;EACb,IAAI,OAAOb,MAAM,KAAK,QAAQ,EAAE;IAC5B,IAAI,CAACA,MAAM,CAACT,MAAM,EAAE;MAChB,MAAM,IAAIK,KAAK,CAACK,kBAAkB,CAAC;IACvC;IACAY,SAAS,GAAGb,MAAM;EACtB,CAAC,MACI;IACD,IAAIA,MAAM,GAAG,CAAC,EAAE;MACZ,MAAM,IAAIJ,KAAK,CAACK,kBAAkB,CAAC;IACvC;IACAY,SAAS,GAAGb,MAAM,CAACV,QAAQ,CAAC,CAAC,CAAC;EAClC;EACA,IAAIc,CAAC,GAAG,CAAC;EACT,MAAMI,IAAI,GAAGA,CAAA,KAAM;IACf,IAAIJ,CAAC,KAAKS,SAAS,CAACtB,MAAM,EAAE;MACxB,OAAO;QAAEkB,IAAI,EAAE,IAAI;QAAElC,KAAK,EAAEmC;MAAU,CAAC;IAC3C;IACA,MAAMI,GAAG,GAAGhB,MAAM,CAACe,SAAS,CAACT,CAAC,CAAC,CAAC;IAChCA,CAAC,EAAE;IACH,OAAO;MAAEK,IAAI,EAAE,KAAK;MAAElC,KAAK,EAAEuC;IAAI,CAAC;EACtC,CAAC;EACD,OAAO;IACH,CAACR,MAAM,CAACC,QAAQ,IAAI;MAChB,OAAO;QAAEC;MAAK,CAAC;IACnB,CAAC;IACDO,kBAAkBA,CAAA,EAAG;MACjB,OAAOF,SAAS,CAACtB,MAAM,GAAGa,CAAC;IAC/B;EACJ,CAAC;AACL;AACA9B,OAAO,CAACO,cAAc,GAAGA,cAAc;AACvC,SAASD,aAAaA,CAACoB,MAAM,EAAE;EAC3B,IAAIa,SAAS;EACb,IAAI,OAAOb,MAAM,KAAK,QAAQ,EAAE;IAC5B,IAAI,CAACA,MAAM,CAACT,MAAM,EAAE;MAChB,MAAM,IAAIK,KAAK,CAACK,kBAAkB,CAAC;IACvC;IACAY,SAAS,GAAGb,MAAM;EACtB,CAAC,MACI;IACD,IAAIA,MAAM,GAAG,CAAC,EAAE;MACZ,MAAM,IAAIJ,KAAK,CAACK,kBAAkB,CAAC;IACvC;IACAY,SAAS,GAAGb,MAAM,CAACV,QAAQ,CAAC,CAAC,CAAC;EAClC;EACA,MAAM0B,IAAI,GAAG,EAAE;EACf,KAAK,IAAIZ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGS,SAAS,CAACtB,MAAM,EAAEa,CAAC,EAAE,EAAE;IACvCY,IAAI,CAACJ,IAAI,CAACd,MAAM,CAACe,SAAS,CAACT,CAAC,CAAC,CAAC,CAAC;EACnC;EACA,OAAOY,IAAI;AACf;AACA1C,OAAO,CAACM,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA,SAASD,cAAcA,CAACgC,QAAQ,EAAE;EAC9B,OAAOhB,MAAM,CAACgB,QAAQ,CAACM,MAAM,CAAC,CAACC,GAAG,EAAElB,MAAM,KAAKkB,GAAG,GAAGlB,MAAM,CAACV,QAAQ,CAAC,CAAC,CAAC,CAAC6B,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;AAC7F;AACA7C,OAAO,CAACK,cAAc,GAAGA,cAAc;AACvC,SAASD,aAAaA,CAACsB,MAAM,EAAE;EAC3B,OAAOA,MAAM,GAAGL,MAAM,CAAC,CAAC,CAAC;AAC7B;AACArB,OAAO,CAACI,aAAa,GAAGA,aAAa;AACrC,SAASD,YAAYA,CAACuB,MAAM,EAAE;EAC1B,OAAOA,MAAM,GAAGL,MAAM,CAAC,CAAC,CAAC;AAC7B;AACArB,OAAO,CAACG,YAAY,GAAGA,YAAY;AACnC,SAASD,WAAWA,CAACwB,MAAM,EAAEoB,UAAU,EAAE;EACrC,OAAOpB,MAAM,GAAGL,MAAM,CAAC,CAAC,CAAC,GAAGA,MAAM,CAACyB,UAAU,CAAC;AAClD;AACA9C,OAAO,CAACE,WAAW,GAAGA,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}