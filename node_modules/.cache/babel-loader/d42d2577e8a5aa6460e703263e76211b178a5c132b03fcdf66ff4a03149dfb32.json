{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;\nconst hasher_1 = require(\"./hasher\");\nconst TWO_POWER_32 = 2 ** 32;\n/**\n * An immutable binary merkle tree node\n */\nclass Node {\n  constructor(h0, h1, h2, h3, h4, h5, h6, h7) {\n    this.h0 = h0;\n    this.h1 = h1;\n    this.h2 = h2;\n    this.h3 = h3;\n    this.h4 = h4;\n    this.h5 = h5;\n    this.h6 = h6;\n    this.h7 = h7;\n  }\n  applyHash(root) {\n    this.h0 = root.h0;\n    this.h1 = root.h1;\n    this.h2 = root.h2;\n    this.h3 = root.h3;\n    this.h4 = root.h4;\n    this.h5 = root.h5;\n    this.h6 = root.h6;\n    this.h7 = root.h7;\n  }\n}\nexports.Node = Node;\n/**\n * An immutable binary merkle tree node that has a `left` and `right` child\n */\nclass BranchNode extends Node {\n  constructor(_left, _right) {\n    // First null value is to save an extra variable to check if a node has a root or not\n    super(null, 0, 0, 0, 0, 0, 0, 0);\n    this._left = _left;\n    this._right = _right;\n    if (!_left) {\n      throw new Error(\"Left node is undefined\");\n    }\n    if (!_right) {\n      throw new Error(\"Right node is undefined\");\n    }\n  }\n  get rootHashObject() {\n    if (this.h0 === null) {\n      super.applyHash(hasher_1.hasher.digest64HashObjects(this.left.rootHashObject, this.right.rootHashObject));\n    }\n    return this;\n  }\n  get root() {\n    return hasher_1.hashObjectToUint8Array(this.rootHashObject);\n  }\n  isLeaf() {\n    return false;\n  }\n  get left() {\n    return this._left;\n  }\n  get right() {\n    return this._right;\n  }\n}\nexports.BranchNode = BranchNode;\n/**\n * An immutable binary merkle tree node that has no children\n */\nclass LeafNode extends Node {\n  static fromRoot(root) {\n    return this.fromHashObject(hasher_1.uint8ArrayToHashObject(root));\n  }\n  /**\n   * New LeafNode from existing HashObject.\n   */\n  static fromHashObject(ho) {\n    return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);\n  }\n  /**\n   * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.\n   */\n  static fromZero() {\n    return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n  }\n  /**\n   * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.\n   */\n  static fromUint32(uint32) {\n    return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);\n  }\n  /**\n   * Create a new LeafNode with the same internal values. The returned instance is safe to mutate\n   */\n  clone() {\n    return LeafNode.fromHashObject(this);\n  }\n  get rootHashObject() {\n    return this;\n  }\n  get root() {\n    return hasher_1.hashObjectToUint8Array(this);\n  }\n  isLeaf() {\n    return true;\n  }\n  get left() {\n    throw Error(\"LeafNode has no left node\");\n  }\n  get right() {\n    throw Error(\"LeafNode has no right node\");\n  }\n  writeToBytes(data, start, size) {\n    // TODO: Optimize\n    data.set(this.root.slice(0, size), start);\n  }\n  getUint(uintBytes, offsetBytes, clipInfinity) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      const h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        return 0xff & h >> bitIndex;\n      } else {\n        return 0xffff & h >> bitIndex;\n      }\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      return getNodeH(this, hIndex) >>> 0;\n    }\n    // number spans 2 h values\n    else if (uintBytes === 8) {\n      const low = getNodeH(this, hIndex);\n      const high = getNodeH(this, hIndex + 1);\n      if (high === 0) {\n        return low >>> 0;\n      } else if (high === -1 && low === -1 && clipInfinity) {\n        // Limit uint returns\n        return Infinity;\n      } else {\n        return (low >>> 0) + (high >>> 0) * TWO_POWER_32;\n      }\n    }\n    // Bigger uint can't be represented\n    else {\n      throw Error(\"uintBytes > 8\");\n    }\n  }\n  getUintBigint(uintBytes, offsetBytes) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      const h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        return BigInt(0xff & h >> bitIndex);\n      } else {\n        return BigInt(0xffff & h >> bitIndex);\n      }\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      return BigInt(getNodeH(this, hIndex) >>> 0);\n    }\n    // number spans multiple h values\n    else {\n      const hRange = Math.ceil(uintBytes / 4);\n      let v = BigInt(0);\n      for (let i = 0; i < hRange; i++) {\n        v += BigInt(getNodeH(this, hIndex + i) >>> 0) << BigInt(32 * i);\n      }\n      return v;\n    }\n  }\n  setUint(uintBytes, offsetBytes, value, clipInfinity) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      let h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        h &= ~(0xff << bitIndex);\n        h |= (0xff && value) << bitIndex;\n      } else {\n        h &= ~(0xffff << bitIndex);\n        h |= (0xffff && value) << bitIndex;\n      }\n      setNodeH(this, hIndex, h);\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      setNodeH(this, hIndex, value);\n    }\n    // number spans 2 h values\n    else if (uintBytes === 8) {\n      if (value === Infinity && clipInfinity) {\n        setNodeH(this, hIndex, -1);\n        setNodeH(this, hIndex + 1, -1);\n      } else {\n        setNodeH(this, hIndex, value & 0xffffffff);\n        setNodeH(this, hIndex + 1, value / TWO_POWER_32 & 0xffffffff);\n      }\n    }\n    // Bigger uint can't be represented\n    else {\n      throw Error(\"uintBytes > 8\");\n    }\n  }\n  setUintBigint(uintBytes, offsetBytes, valueBN) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const value = Number(valueBN);\n      const bitIndex = offsetBytes % 4 * 8;\n      let h = getNodeH(this, hIndex);\n      if (uintBytes === 1) {\n        h &= ~(0xff << bitIndex);\n        h |= (0xff && value) << bitIndex;\n      } else {\n        h &= ~(0xffff << bitIndex);\n        h |= (0xffff && value) << bitIndex;\n      }\n      setNodeH(this, hIndex, h);\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      setNodeH(this, hIndex, Number(valueBN));\n    }\n    // number spans multiple h values\n    else {\n      const hEnd = hIndex + Math.ceil(uintBytes / 4);\n      for (let i = hIndex; i < hEnd; i++) {\n        setNodeH(this, i, Number(valueBN & BigInt(0xffffffff)));\n        valueBN = valueBN >> BigInt(32);\n      }\n    }\n  }\n  bitwiseOrUint(uintBytes, offsetBytes, value) {\n    const hIndex = Math.floor(offsetBytes / 4);\n    // number has to be masked from an h value\n    if (uintBytes < 4) {\n      const bitIndex = offsetBytes % 4 * 8;\n      bitwiseOrNodeH(this, hIndex, value << bitIndex);\n    }\n    // number equals the h value\n    else if (uintBytes === 4) {\n      bitwiseOrNodeH(this, hIndex, value);\n    }\n    // number spans multiple h values\n    else {\n      const hEnd = hIndex + Math.ceil(uintBytes / 4);\n      for (let i = hIndex; i < hEnd; i++) {\n        bitwiseOrNodeH(this, i, value & 0xffffffff);\n        value >>= 32;\n      }\n    }\n  }\n}\nexports.LeafNode = LeafNode;\nfunction identity(n) {\n  return n;\n}\nexports.identity = identity;\nfunction compose(inner, outer) {\n  return function (n) {\n    return outer(inner(n));\n  };\n}\nexports.compose = compose;\nfunction getNodeH(node, hIndex) {\n  if (hIndex === 0) return node.h0;else if (hIndex === 1) return node.h1;else if (hIndex === 2) return node.h2;else if (hIndex === 3) return node.h3;else if (hIndex === 4) return node.h4;else if (hIndex === 5) return node.h5;else if (hIndex === 6) return node.h6;else if (hIndex === 7) return node.h7;else throw Error(\"hIndex > 7\");\n}\nexports.getNodeH = getNodeH;\nfunction setNodeH(node, hIndex, value) {\n  if (hIndex === 0) node.h0 = value;else if (hIndex === 1) node.h1 = value;else if (hIndex === 2) node.h2 = value;else if (hIndex === 3) node.h3 = value;else if (hIndex === 4) node.h4 = value;else if (hIndex === 5) node.h5 = value;else if (hIndex === 6) node.h6 = value;else if (hIndex === 7) node.h7 = value;else throw Error(\"hIndex > 7\");\n}\nexports.setNodeH = setNodeH;\nfunction bitwiseOrNodeH(node, hIndex, value) {\n  if (hIndex === 0) node.h0 |= value;else if (hIndex === 1) node.h1 |= value;else if (hIndex === 2) node.h2 |= value;else if (hIndex === 3) node.h3 |= value;else if (hIndex === 4) node.h4 |= value;else if (hIndex === 5) node.h5 |= value;else if (hIndex === 6) node.h6 |= value;else if (hIndex === 7) node.h7 |= value;else throw Error(\"hIndex > 7\");\n}\nexports.bitwiseOrNodeH = bitwiseOrNodeH;","map":{"version":3,"names":["Object","defineProperty","exports","value","bitwiseOrNodeH","setNodeH","getNodeH","compose","identity","LeafNode","BranchNode","Node","hasher_1","require","TWO_POWER_32","constructor","h0","h1","h2","h3","h4","h5","h6","h7","applyHash","root","_left","_right","Error","rootHashObject","hasher","digest64HashObjects","left","right","hashObjectToUint8Array","isLeaf","fromRoot","fromHashObject","uint8ArrayToHashObject","ho","fromZero","fromUint32","uint32","clone","writeToBytes","data","start","size","set","slice","getUint","uintBytes","offsetBytes","clipInfinity","hIndex","Math","floor","bitIndex","h","low","high","Infinity","getUintBigint","BigInt","hRange","ceil","v","i","setUint","setUintBigint","valueBN","Number","hEnd","bitwiseOrUint","n","inner","outer","node"],"sources":["/hood3/node_modules/@chainsafe/persistent-merkle-tree/lib/node.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bitwiseOrNodeH = exports.setNodeH = exports.getNodeH = exports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;\nconst hasher_1 = require(\"./hasher\");\nconst TWO_POWER_32 = 2 ** 32;\n/**\n * An immutable binary merkle tree node\n */\nclass Node {\n    constructor(h0, h1, h2, h3, h4, h5, h6, h7) {\n        this.h0 = h0;\n        this.h1 = h1;\n        this.h2 = h2;\n        this.h3 = h3;\n        this.h4 = h4;\n        this.h5 = h5;\n        this.h6 = h6;\n        this.h7 = h7;\n    }\n    applyHash(root) {\n        this.h0 = root.h0;\n        this.h1 = root.h1;\n        this.h2 = root.h2;\n        this.h3 = root.h3;\n        this.h4 = root.h4;\n        this.h5 = root.h5;\n        this.h6 = root.h6;\n        this.h7 = root.h7;\n    }\n}\nexports.Node = Node;\n/**\n * An immutable binary merkle tree node that has a `left` and `right` child\n */\nclass BranchNode extends Node {\n    constructor(_left, _right) {\n        // First null value is to save an extra variable to check if a node has a root or not\n        super(null, 0, 0, 0, 0, 0, 0, 0);\n        this._left = _left;\n        this._right = _right;\n        if (!_left) {\n            throw new Error(\"Left node is undefined\");\n        }\n        if (!_right) {\n            throw new Error(\"Right node is undefined\");\n        }\n    }\n    get rootHashObject() {\n        if (this.h0 === null) {\n            super.applyHash(hasher_1.hasher.digest64HashObjects(this.left.rootHashObject, this.right.rootHashObject));\n        }\n        return this;\n    }\n    get root() {\n        return hasher_1.hashObjectToUint8Array(this.rootHashObject);\n    }\n    isLeaf() {\n        return false;\n    }\n    get left() {\n        return this._left;\n    }\n    get right() {\n        return this._right;\n    }\n}\nexports.BranchNode = BranchNode;\n/**\n * An immutable binary merkle tree node that has no children\n */\nclass LeafNode extends Node {\n    static fromRoot(root) {\n        return this.fromHashObject(hasher_1.uint8ArrayToHashObject(root));\n    }\n    /**\n     * New LeafNode from existing HashObject.\n     */\n    static fromHashObject(ho) {\n        return new LeafNode(ho.h0, ho.h1, ho.h2, ho.h3, ho.h4, ho.h5, ho.h6, ho.h7);\n    }\n    /**\n     * New LeafNode with its internal value set to zero. Consider using `zeroNode(0)` if you don't need to mutate.\n     */\n    static fromZero() {\n        return new LeafNode(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    /**\n     * LeafNode with HashObject `(uint32, 0, 0, 0, 0, 0, 0, 0)`.\n     */\n    static fromUint32(uint32) {\n        return new LeafNode(uint32, 0, 0, 0, 0, 0, 0, 0);\n    }\n    /**\n     * Create a new LeafNode with the same internal values. The returned instance is safe to mutate\n     */\n    clone() {\n        return LeafNode.fromHashObject(this);\n    }\n    get rootHashObject() {\n        return this;\n    }\n    get root() {\n        return hasher_1.hashObjectToUint8Array(this);\n    }\n    isLeaf() {\n        return true;\n    }\n    get left() {\n        throw Error(\"LeafNode has no left node\");\n    }\n    get right() {\n        throw Error(\"LeafNode has no right node\");\n    }\n    writeToBytes(data, start, size) {\n        // TODO: Optimize\n        data.set(this.root.slice(0, size), start);\n    }\n    getUint(uintBytes, offsetBytes, clipInfinity) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            const h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                return 0xff & (h >> bitIndex);\n            }\n            else {\n                return 0xffff & (h >> bitIndex);\n            }\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            return getNodeH(this, hIndex) >>> 0;\n        }\n        // number spans 2 h values\n        else if (uintBytes === 8) {\n            const low = getNodeH(this, hIndex);\n            const high = getNodeH(this, hIndex + 1);\n            if (high === 0) {\n                return low >>> 0;\n            }\n            else if (high === -1 && low === -1 && clipInfinity) {\n                // Limit uint returns\n                return Infinity;\n            }\n            else {\n                return (low >>> 0) + (high >>> 0) * TWO_POWER_32;\n            }\n        }\n        // Bigger uint can't be represented\n        else {\n            throw Error(\"uintBytes > 8\");\n        }\n    }\n    getUintBigint(uintBytes, offsetBytes) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            const h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                return BigInt(0xff & (h >> bitIndex));\n            }\n            else {\n                return BigInt(0xffff & (h >> bitIndex));\n            }\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            return BigInt(getNodeH(this, hIndex) >>> 0);\n        }\n        // number spans multiple h values\n        else {\n            const hRange = Math.ceil(uintBytes / 4);\n            let v = BigInt(0);\n            for (let i = 0; i < hRange; i++) {\n                v += BigInt(getNodeH(this, hIndex + i) >>> 0) << BigInt(32 * i);\n            }\n            return v;\n        }\n    }\n    setUint(uintBytes, offsetBytes, value, clipInfinity) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            let h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                h &= ~(0xff << bitIndex);\n                h |= (0xff && value) << bitIndex;\n            }\n            else {\n                h &= ~(0xffff << bitIndex);\n                h |= (0xffff && value) << bitIndex;\n            }\n            setNodeH(this, hIndex, h);\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            setNodeH(this, hIndex, value);\n        }\n        // number spans 2 h values\n        else if (uintBytes === 8) {\n            if (value === Infinity && clipInfinity) {\n                setNodeH(this, hIndex, -1);\n                setNodeH(this, hIndex + 1, -1);\n            }\n            else {\n                setNodeH(this, hIndex, value & 0xffffffff);\n                setNodeH(this, hIndex + 1, (value / TWO_POWER_32) & 0xffffffff);\n            }\n        }\n        // Bigger uint can't be represented\n        else {\n            throw Error(\"uintBytes > 8\");\n        }\n    }\n    setUintBigint(uintBytes, offsetBytes, valueBN) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const value = Number(valueBN);\n            const bitIndex = (offsetBytes % 4) * 8;\n            let h = getNodeH(this, hIndex);\n            if (uintBytes === 1) {\n                h &= ~(0xff << bitIndex);\n                h |= (0xff && value) << bitIndex;\n            }\n            else {\n                h &= ~(0xffff << bitIndex);\n                h |= (0xffff && value) << bitIndex;\n            }\n            setNodeH(this, hIndex, h);\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            setNodeH(this, hIndex, Number(valueBN));\n        }\n        // number spans multiple h values\n        else {\n            const hEnd = hIndex + Math.ceil(uintBytes / 4);\n            for (let i = hIndex; i < hEnd; i++) {\n                setNodeH(this, i, Number(valueBN & BigInt(0xffffffff)));\n                valueBN = valueBN >> BigInt(32);\n            }\n        }\n    }\n    bitwiseOrUint(uintBytes, offsetBytes, value) {\n        const hIndex = Math.floor(offsetBytes / 4);\n        // number has to be masked from an h value\n        if (uintBytes < 4) {\n            const bitIndex = (offsetBytes % 4) * 8;\n            bitwiseOrNodeH(this, hIndex, value << bitIndex);\n        }\n        // number equals the h value\n        else if (uintBytes === 4) {\n            bitwiseOrNodeH(this, hIndex, value);\n        }\n        // number spans multiple h values\n        else {\n            const hEnd = hIndex + Math.ceil(uintBytes / 4);\n            for (let i = hIndex; i < hEnd; i++) {\n                bitwiseOrNodeH(this, i, value & 0xffffffff);\n                value >>= 32;\n            }\n        }\n    }\n}\nexports.LeafNode = LeafNode;\nfunction identity(n) {\n    return n;\n}\nexports.identity = identity;\nfunction compose(inner, outer) {\n    return function (n) {\n        return outer(inner(n));\n    };\n}\nexports.compose = compose;\nfunction getNodeH(node, hIndex) {\n    if (hIndex === 0)\n        return node.h0;\n    else if (hIndex === 1)\n        return node.h1;\n    else if (hIndex === 2)\n        return node.h2;\n    else if (hIndex === 3)\n        return node.h3;\n    else if (hIndex === 4)\n        return node.h4;\n    else if (hIndex === 5)\n        return node.h5;\n    else if (hIndex === 6)\n        return node.h6;\n    else if (hIndex === 7)\n        return node.h7;\n    else\n        throw Error(\"hIndex > 7\");\n}\nexports.getNodeH = getNodeH;\nfunction setNodeH(node, hIndex, value) {\n    if (hIndex === 0)\n        node.h0 = value;\n    else if (hIndex === 1)\n        node.h1 = value;\n    else if (hIndex === 2)\n        node.h2 = value;\n    else if (hIndex === 3)\n        node.h3 = value;\n    else if (hIndex === 4)\n        node.h4 = value;\n    else if (hIndex === 5)\n        node.h5 = value;\n    else if (hIndex === 6)\n        node.h6 = value;\n    else if (hIndex === 7)\n        node.h7 = value;\n    else\n        throw Error(\"hIndex > 7\");\n}\nexports.setNodeH = setNodeH;\nfunction bitwiseOrNodeH(node, hIndex, value) {\n    if (hIndex === 0)\n        node.h0 |= value;\n    else if (hIndex === 1)\n        node.h1 |= value;\n    else if (hIndex === 2)\n        node.h2 |= value;\n    else if (hIndex === 3)\n        node.h3 |= value;\n    else if (hIndex === 4)\n        node.h4 |= value;\n    else if (hIndex === 5)\n        node.h5 |= value;\n    else if (hIndex === 6)\n        node.h6 |= value;\n    else if (hIndex === 7)\n        node.h7 |= value;\n    else\n        throw Error(\"hIndex > 7\");\n}\nexports.bitwiseOrNodeH = bitwiseOrNodeH;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}