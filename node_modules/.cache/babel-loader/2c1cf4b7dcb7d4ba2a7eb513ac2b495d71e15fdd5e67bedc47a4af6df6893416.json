{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextPowerOf2 = exports.maxChunksToDepth = exports.bitLength = exports.mixInLength = exports.splitIntoRootChunks = exports.merkleize = exports.hash64 = void 0;\nconst index_1 = require(\"@chainsafe/persistent-merkle-tree/lib/hasher/index\");\nconst zeros_1 = require(\"./zeros\");\nfunction hash64(bytes32A, bytes32B) {\n  return index_1.hasher.digest64(bytes32A, bytes32B);\n}\nexports.hash64 = hash64;\nfunction merkleize(chunks, padFor) {\n  const layerCount = bitLength(nextPowerOf2(padFor) - 1);\n  if (chunks.length == 0) {\n    return zeros_1.zeroHash(layerCount);\n  }\n  let chunkCount = chunks.length;\n  // Instead of pushing on all padding zero chunks at the leaf level\n  // we push on zero hash chunks at the highest possible level to avoid over-hashing\n  for (let l = 0; l < layerCount; l++) {\n    const padCount = chunkCount % 2;\n    const paddedChunkCount = chunkCount + padCount;\n    // if the chunks.length is odd\n    // we need to push on the zero-hash of that level to merkleize that level\n    for (let i = 0; i < padCount; i++) {\n      chunks[chunkCount + i] = zeros_1.zeroHash(l);\n    }\n    for (let i = 0; i < paddedChunkCount; i += 2) {\n      chunks[i / 2] = hash64(chunks[i], chunks[i + 1]);\n    }\n    chunkCount = paddedChunkCount / 2;\n  }\n  return chunks[0];\n}\nexports.merkleize = merkleize;\n/**\n * Split a long Uint8Array into Uint8Array of exactly 32 bytes\n */\nfunction splitIntoRootChunks(longChunk) {\n  const chunkCount = Math.ceil(longChunk.length / 32);\n  const chunks = new Array(chunkCount);\n  for (let i = 0; i < chunkCount; i++) {\n    const chunk = new Uint8Array(32);\n    chunk.set(longChunk.slice(i * 32, (i + 1) * 32));\n    chunks[i] = chunk;\n  }\n  return chunks;\n}\nexports.splitIntoRootChunks = splitIntoRootChunks;\n/** @ignore */\nfunction mixInLength(root, length) {\n  const lengthBuf = Buffer.alloc(32);\n  lengthBuf.writeUIntLE(length, 0, 6);\n  return hash64(root, lengthBuf);\n}\nexports.mixInLength = mixInLength;\n// x2 faster than bitLengthStr() which uses Number.toString(2)\nfunction bitLength(i) {\n  if (i === 0) {\n    return 0;\n  }\n  return Math.floor(Math.log2(i)) + 1;\n}\nexports.bitLength = bitLength;\n/**\n * Given maxChunkCount return the chunkDepth\n * ```\n * n: [0,1,2,3,4,5,6,7,8,9]\n * d: [0,0,1,2,2,3,3,3,3,4]\n * ```\n */\nfunction maxChunksToDepth(n) {\n  if (n === 0) return 0;\n  return Math.ceil(Math.log2(n));\n}\nexports.maxChunksToDepth = maxChunksToDepth;\n/** @ignore */\nfunction nextPowerOf2(n) {\n  return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));\n}\nexports.nextPowerOf2 = nextPowerOf2;","map":{"version":3,"names":["index_1","require","zeros_1","hash64","bytes32A","bytes32B","hasher","digest64","exports","merkleize","chunks","padFor","layerCount","bitLength","nextPowerOf2","length","zeroHash","chunkCount","l","padCount","paddedChunkCount","i","splitIntoRootChunks","longChunk","Math","ceil","Array","chunk","Uint8Array","set","slice","mixInLength","root","lengthBuf","Buffer","alloc","writeUIntLE","floor","log2","maxChunksToDepth","n","pow"],"sources":["../../src/util/merkleize.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}