{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = exports.descriptorToBitlist = exports.computeDescriptor = void 0;\nconst multi_1 = require(\"./multi\");\nconst compactMulti_1 = require(\"./compactMulti\");\nconst single_1 = require(\"./single\");\nconst treeOffset_1 = require(\"./treeOffset\");\nvar compactMulti_2 = require(\"./compactMulti\");\nObject.defineProperty(exports, \"computeDescriptor\", {\n  enumerable: true,\n  get: function () {\n    return compactMulti_2.computeDescriptor;\n  }\n});\nObject.defineProperty(exports, \"descriptorToBitlist\", {\n  enumerable: true,\n  get: function () {\n    return compactMulti_2.descriptorToBitlist;\n  }\n});\nvar ProofType;\n(function (ProofType) {\n  ProofType[\"single\"] = \"single\";\n  ProofType[\"treeOffset\"] = \"treeOffset\";\n  ProofType[\"multi\"] = \"multi\";\n  ProofType[\"compactMulti\"] = \"compactMulti\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\nexports.ProofTypeSerialized = [ProofType.single, ProofType.treeOffset, ProofType.multi, ProofType.compactMulti // 3\n];\n\nfunction createProof(rootNode, input) {\n  switch (input.type) {\n    case ProofType.single:\n      {\n        const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n        return {\n          type: ProofType.single,\n          gindex: input.gindex,\n          leaf,\n          witnesses\n        };\n      }\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n    case ProofType.multi:\n      {\n        const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);\n        return {\n          type: ProofType.multi,\n          leaves,\n          witnesses,\n          gindices\n        };\n      }\n    case ProofType.compactMulti:\n      {\n        const leaves = compactMulti_1.createCompactMultiProof(rootNode, input.descriptor);\n        return {\n          type: ProofType.compactMulti,\n          leaves,\n          descriptor: input.descriptor\n        };\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.createProof = createProof;\nfunction createNodeFromProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n      return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n    case ProofType.treeOffset:\n      return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n    case ProofType.multi:\n      return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);\n    case ProofType.compactMulti:\n      return compactMulti_1.createNodeFromCompactMultiProof(proof.leaves, proof.descriptor);\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.createNodeFromProof = createNodeFromProof;\nfunction serializeProof(proof) {\n  switch (proof.type) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n    case ProofType.treeOffset:\n      {\n        const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n        output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n        treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n        return output;\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.serializeProof = serializeProof;\nfunction deserializeProof(data) {\n  const proofType = exports.ProofTypeSerialized[data[0]];\n  if (!proofType) {\n    throw new Error(\"Invalid proof type\");\n  }\n  switch (proofType) {\n    case ProofType.single:\n    case ProofType.multi:\n      throw new Error(\"Not implemented\");\n    case ProofType.treeOffset:\n      {\n        const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n        return {\n          type: ProofType.treeOffset,\n          offsets,\n          leaves\n        };\n      }\n    default:\n      throw new Error(\"Invalid proof type\");\n  }\n}\nexports.deserializeProof = deserializeProof;","map":{"version":3,"names":["Object","defineProperty","exports","value","deserializeProof","serializeProof","createNodeFromProof","createProof","ProofTypeSerialized","ProofType","descriptorToBitlist","computeDescriptor","multi_1","require","compactMulti_1","single_1","treeOffset_1","compactMulti_2","enumerable","get","single","treeOffset","multi","compactMulti","rootNode","input","type","leaf","witnesses","createSingleProof","gindex","offsets","leaves","createTreeOffsetProof","gindices","createMultiProof","createCompactMultiProof","descriptor","Error","proof","createNodeFromSingleProof","createNodeFromTreeOffsetProof","createNodeFromMultiProof","createNodeFromCompactMultiProof","output","Uint8Array","computeTreeOffsetProofSerializedLength","indexOf","serializeTreeOffsetProof","data","proofType","deserializeTreeOffsetProof"],"sources":["/hood3/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = exports.descriptorToBitlist = exports.computeDescriptor = void 0;\nconst multi_1 = require(\"./multi\");\nconst compactMulti_1 = require(\"./compactMulti\");\nconst single_1 = require(\"./single\");\nconst treeOffset_1 = require(\"./treeOffset\");\nvar compactMulti_2 = require(\"./compactMulti\");\nObject.defineProperty(exports, \"computeDescriptor\", { enumerable: true, get: function () { return compactMulti_2.computeDescriptor; } });\nObject.defineProperty(exports, \"descriptorToBitlist\", { enumerable: true, get: function () { return compactMulti_2.descriptorToBitlist; } });\nvar ProofType;\n(function (ProofType) {\n    ProofType[\"single\"] = \"single\";\n    ProofType[\"treeOffset\"] = \"treeOffset\";\n    ProofType[\"multi\"] = \"multi\";\n    ProofType[\"compactMulti\"] = \"compactMulti\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\nexports.ProofTypeSerialized = [\n    ProofType.single,\n    ProofType.treeOffset,\n    ProofType.multi,\n    ProofType.compactMulti, // 3\n];\nfunction createProof(rootNode, input) {\n    switch (input.type) {\n        case ProofType.single: {\n            const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n            return {\n                type: ProofType.single,\n                gindex: input.gindex,\n                leaf,\n                witnesses,\n            };\n        }\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        case ProofType.multi: {\n            const [leaves, witnesses, gindices] = multi_1.createMultiProof(rootNode, input.gindices);\n            return {\n                type: ProofType.multi,\n                leaves,\n                witnesses,\n                gindices,\n            };\n        }\n        case ProofType.compactMulti: {\n            const leaves = compactMulti_1.createCompactMultiProof(rootNode, input.descriptor);\n            return {\n                type: ProofType.compactMulti,\n                leaves,\n                descriptor: input.descriptor,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createProof = createProof;\nfunction createNodeFromProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n            return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n        case ProofType.treeOffset:\n            return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n        case ProofType.multi:\n            return multi_1.createNodeFromMultiProof(proof.leaves, proof.witnesses, proof.gindices);\n        case ProofType.compactMulti:\n            return compactMulti_1.createNodeFromCompactMultiProof(proof.leaves, proof.descriptor);\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createNodeFromProof = createNodeFromProof;\nfunction serializeProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n        case ProofType.multi:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n            output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n            treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n            return output;\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.serializeProof = serializeProof;\nfunction deserializeProof(data) {\n    const proofType = exports.ProofTypeSerialized[data[0]];\n    if (!proofType) {\n        throw new Error(\"Invalid proof type\");\n    }\n    switch (proofType) {\n        case ProofType.single:\n        case ProofType.multi:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.deserializeProof = deserializeProof;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}