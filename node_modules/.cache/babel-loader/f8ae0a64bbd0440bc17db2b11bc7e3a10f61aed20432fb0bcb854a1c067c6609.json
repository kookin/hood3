{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.value_getRootsArrayComposite = exports.tree_deserializeFromBytesArrayComposite = exports.tree_serializeToBytesArrayComposite = exports.tree_serializedSizeArrayComposite = exports.value_deserializeFromBytesArrayComposite = exports.value_serializeToBytesArrayComposite = exports.value_serializedSizeArrayComposite = exports.maxSizeArrayComposite = exports.minSizeArrayComposite = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nfunction minSizeArrayComposite(elementType, minCount) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    return minCount * (4 + elementType.minSize);\n  }\n  // Fixed length\n  else {\n    return minCount * elementType.minSize;\n  }\n}\nexports.minSizeArrayComposite = minSizeArrayComposite;\nfunction maxSizeArrayComposite(elementType, maxCount) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    return maxCount * (4 + elementType.maxSize);\n  }\n  // Fixed length\n  else {\n    return maxCount * elementType.maxSize;\n  }\n}\nexports.maxSizeArrayComposite = maxSizeArrayComposite;\nfunction value_serializedSizeArrayComposite(elementType, length, value) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    let size = 0;\n    for (let i = 0; i < length; i++) {\n      size += 4 + elementType.value_serializedSize(value[i]);\n    }\n    return size;\n  }\n  // Fixed length\n  else {\n    return length * elementType.fixedSize;\n  }\n}\nexports.value_serializedSizeArrayComposite = value_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_serializeToBytesArrayComposite(elementType, length, output, offset, value) {\n  // Variable length\n  if (elementType.fixedSize === null) {\n    let variableIndex = offset + length * 4;\n    for (let i = 0; i < length; i++) {\n      // write offset\n      output.dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n      // write serialized element to variable section\n      variableIndex = elementType.value_serializeToBytes(output, variableIndex, value[i]);\n    }\n    return variableIndex;\n  }\n  // Fixed length\n  else {\n    for (let i = 0; i < length; i++) {\n      elementType.value_serializeToBytes(output, offset + i * elementType.fixedSize, value[i]);\n    }\n    return offset + length * elementType.fixedSize;\n  }\n}\nexports.value_serializeToBytesArrayComposite = value_serializeToBytesArrayComposite;\nfunction value_deserializeFromBytesArrayComposite(elementType, data, start, end, arrayProps) {\n  const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n  const length = offsets.length; // Capture length before pushing end offset\n  const values = new Array(length);\n  // offests include the last element end\n  for (let i = 0; i < length; i++) {\n    // The offsets are relative to the start\n    const startEl = start + offsets[i];\n    const endEl = i === length - 1 ? end : start + offsets[i + 1];\n    values[i] = elementType.value_deserializeFromBytes(data, startEl, endEl);\n  }\n  return values;\n}\nexports.value_deserializeFromBytesArrayComposite = value_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializedSizeArrayComposite(elementType, length, depth, node) {\n  // Variable Length\n  if (elementType.fixedSize === null) {\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n    let size = 0;\n    for (let i = 0; i < nodes.length; i++) {\n      size += 4 + elementType.tree_serializedSize(nodes[i]);\n    }\n    return size;\n  }\n  // Fixed length\n  else {\n    return length * elementType.fixedSize;\n  }\n}\nexports.tree_serializedSizeArrayComposite = tree_serializedSizeArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction tree_serializeToBytesArrayComposite(elementType, length, depth, node, output, offset) {\n  const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, depth, 0, length);\n  // Variable Length\n  // Indices contain offsets, which are indices deeper in the byte array\n  if (elementType.fixedSize === null) {\n    let variableIndex = offset + length * 4;\n    const {\n      dataView\n    } = output;\n    for (let i = 0; i < nodes.length; i++) {\n      // write offset\n      dataView.setUint32(offset + i * 4, variableIndex - offset, true);\n      // write serialized element to variable section\n      variableIndex = elementType.tree_serializeToBytes(output, variableIndex, nodes[i]);\n    }\n    return variableIndex;\n  }\n  // Fixed length\n  else {\n    for (let i = 0; i < nodes.length; i++) {\n      offset = elementType.tree_serializeToBytes(output, offset, nodes[i]);\n    }\n    return offset;\n  }\n}\nexports.tree_serializeToBytesArrayComposite = tree_serializeToBytesArrayComposite;\nfunction tree_deserializeFromBytesArrayComposite(elementType, chunkDepth, data, start, end, arrayProps) {\n  const offsets = readOffsetsArrayComposite(elementType.fixedSize, data.dataView, start, end, arrayProps);\n  const length = offsets.length; // Capture length before pushing end offset\n  const nodes = new Array(length);\n  // offests include the last element end\n  for (let i = 0; i < length; i++) {\n    // The offsets are relative to the start\n    const startEl = start + offsets[i];\n    const endEl = i === length - 1 ? end : start + offsets[i + 1];\n    nodes[i] = elementType.tree_deserializeFromBytes(data, startEl, endEl);\n  }\n  // Abstract converting data to LeafNode to allow for custom data representation, such as the hashObject\n  const chunksNode = persistent_merkle_tree_1.subtreeFillToContents(nodes, chunkDepth);\n  // TODO: Add LeafNode.fromUint()\n  if (arrayProps.isList) {\n    return arrayBasic_1.addLengthNode(chunksNode, length);\n  } else {\n    return chunksNode;\n  }\n}\nexports.tree_deserializeFromBytesArrayComposite = tree_deserializeFromBytesArrayComposite;\n/**\n * @param length In List length = value.length, Vector length = fixed value\n */\nfunction value_getRootsArrayComposite(elementType, length, value) {\n  const roots = new Array(length);\n  for (let i = 0; i < length; i++) {\n    roots[i] = elementType.hashTreeRoot(value[i]);\n  }\n  return roots;\n}\nexports.value_getRootsArrayComposite = value_getRootsArrayComposite;\nfunction readOffsetsArrayComposite(elementFixedSize, data, start, end, arrayProps) {\n  const size = end - start;\n  let offsets;\n  // Variable Length\n  // Indices contain offsets, which are indices deeper in the byte array\n  if (elementFixedSize === null) {\n    offsets = readVariableOffsetsArrayComposite(data, start, size);\n  }\n  // Fixed length\n  else {\n    // There's no valid CompositeType with fixed size 0, it's un-rechable code. But prevents diving by zero\n    /* istanbul ignore if */\n    if (elementFixedSize === 0) {\n      throw Error(\"element fixed length is 0\");\n    }\n    if (size % elementFixedSize !== 0) {\n      throw Error(`size ${size} is not multiple of element fixedSize ${elementFixedSize}`);\n    }\n    const length = size / elementFixedSize;\n    offsets = new Uint32Array(length);\n    for (let i = 0; i < length; i++) {\n      offsets[i] = i * elementFixedSize;\n    }\n  }\n  // Vector + List length validation\n  arrayBasic_1.assertValidArrayLength(offsets.length, arrayProps);\n  return offsets;\n}\n/**\n * Reads the values of contiguous variable offsets. Provided buffer includes offsets that point to position\n * within `size`. This function also validates that all offsets are in range.\n */\nfunction readVariableOffsetsArrayComposite(dataView, start, size) {\n  if (size === 0) {\n    return new Uint32Array(0);\n  }\n  // all elements are variable-sized\n  // indices contain offsets, which are indices deeper in the byte array\n  // The serialized data will start with offsets of all the serialized objects (BYTES_PER_LENGTH_OFFSET bytes each)\n  const firstOffset = dataView.getUint32(start, true);\n  // Using the first offset, we can compute the length of the list (divide by BYTES_PER_LENGTH_OFFSET), as it gives\n  // us the total number of bytes in the offset data\n  const offsetDataLength = firstOffset;\n  if (firstOffset === 0) {\n    throw Error(\"First offset must be > 0\");\n  }\n  if (offsetDataLength % 4 !== 0) {\n    throw Error(\"Offset data length not multiple of 4\");\n  }\n  const offsetCount = offsetDataLength / 4;\n  const offsets = new Uint32Array(offsetCount);\n  offsets[0] = firstOffset;\n  // ArrayComposite has a contiguous section of offsets, then the data\n  //\n  //    [offset 1] [offset 2] [data 1 ..........] [data 2 ..]\n  // 0x 08000000   0e000000   010002000300        01000200\n  //\n  // Ensure that:\n  // - Offsets point to regions of > 0 bytes, i.e. are increasing\n  // - Offsets don't point to bytes outside of the array's size\n  //\n  // In the example above the first offset is 8, so 8 / 4 = 2 offsets.\n  // Then, read the rest of offsets to get offsets = [8, 14]\n  for (let offsetIdx = 1; offsetIdx < offsetCount; offsetIdx++) {\n    const offset = dataView.getUint32(start + offsetIdx * 4, true);\n    offsets[offsetIdx] = offset;\n    // Offsets must point to data within the Array bytes section\n    if (offset > size) {\n      throw new Error(`Offset out of bounds ${offset} > ${size}`);\n    }\n    if (offset < offsets[offsetIdx - 1]) {\n      throw new Error(`Offsets must be increasing ${offset} < ${offsets[offsetIdx - 1]}`);\n    }\n  }\n  return offsets;\n}","map":{"version":3,"names":["persistent_merkle_tree_1","require","arrayBasic_1","minSizeArrayComposite","elementType","minCount","fixedSize","minSize","exports","maxSizeArrayComposite","maxCount","maxSize","value_serializedSizeArrayComposite","length","value","size","i","value_serializedSize","value_serializeToBytesArrayComposite","output","offset","variableIndex","dataView","setUint32","value_serializeToBytes","value_deserializeFromBytesArrayComposite","data","start","end","arrayProps","offsets","readOffsetsArrayComposite","values","Array","startEl","endEl","value_deserializeFromBytes","tree_serializedSizeArrayComposite","depth","node","nodes","getNodesAtDepth","tree_serializedSize","tree_serializeToBytesArrayComposite","tree_serializeToBytes","tree_deserializeFromBytesArrayComposite","chunkDepth","tree_deserializeFromBytes","chunksNode","subtreeFillToContents","isList","addLengthNode","value_getRootsArrayComposite","roots","hashTreeRoot","elementFixedSize","readVariableOffsetsArrayComposite","Error","Uint32Array","assertValidArrayLength","firstOffset","getUint32","offsetDataLength","offsetCount","offsetIdx"],"sources":["../../src/type/arrayComposite.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}