{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createNodeFromCompactMultiProof = exports.createCompactMultiProof = exports.compactMultiProofToNode = exports.nodeToCompactMultiProof = exports.descriptorToBitlist = exports.computeDescriptor = void 0;\nconst gindex_1 = require(\"../gindex\");\nconst node_1 = require(\"../node\");\nconst util_1 = require(\"./util\");\nfunction computeDescriptor(indices) {\n  // include all helper indices\n  const proofBitstrings = new Set();\n  const pathBitstrings = new Set();\n  for (const leafIndex of indices) {\n    const leafBitstring = gindex_1.convertGindexToBitstring(leafIndex);\n    proofBitstrings.add(leafBitstring);\n    const {\n      branch,\n      path\n    } = util_1.computeProofBitstrings(leafBitstring);\n    path.delete(leafBitstring);\n    for (const pathIndex of path) {\n      pathBitstrings.add(pathIndex);\n    }\n    for (const branchIndex of branch) {\n      proofBitstrings.add(branchIndex);\n    }\n  }\n  for (const pathIndex of pathBitstrings) {\n    proofBitstrings.delete(pathIndex);\n  }\n  // sort gindex bitstrings in-order\n  const allBitstringsSorted = Array.from(proofBitstrings).sort((a, b) => a.localeCompare(b));\n  // convert gindex bitstrings into descriptor bitstring\n  let descriptorBitstring = \"\";\n  for (const gindexBitstring of allBitstringsSorted) {\n    for (let i = 0; i < gindexBitstring.length; i++) {\n      if (gindexBitstring[gindexBitstring.length - 1 - i] === \"1\") {\n        descriptorBitstring += \"1\".padStart(i + 1, \"0\");\n        break;\n      }\n    }\n  }\n  // append zero bits to byte-alignt\n  if (descriptorBitstring.length % 8 != 0) {\n    descriptorBitstring = descriptorBitstring.padEnd(8 - descriptorBitstring.length % 8 + descriptorBitstring.length, \"0\");\n  }\n  // convert descriptor bitstring to bytes\n  const descriptor = new Uint8Array(descriptorBitstring.length / 8);\n  for (let i = 0; i < descriptor.length; i++) {\n    descriptor[i] = Number(\"0b\" + descriptorBitstring.substring(i * 8, (i + 1) * 8));\n  }\n  return descriptor;\n}\nexports.computeDescriptor = computeDescriptor;\nfunction getBit(bitlist, bitIndex) {\n  const bit = bitIndex % 8;\n  const byteIdx = Math.floor(bitIndex / 8);\n  const byte = bitlist[byteIdx];\n  switch (bit) {\n    case 0:\n      return (byte & 0b1000_0000) !== 0;\n    case 1:\n      return (byte & 0b0100_0000) !== 0;\n    case 2:\n      return (byte & 0b0010_0000) !== 0;\n    case 3:\n      return (byte & 0b0001_0000) !== 0;\n    case 4:\n      return (byte & 0b0000_1000) !== 0;\n    case 5:\n      return (byte & 0b0000_0100) !== 0;\n    case 6:\n      return (byte & 0b0000_0010) !== 0;\n    case 7:\n      return (byte & 0b0000_0001) !== 0;\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction descriptorToBitlist(descriptor) {\n  const bools = [];\n  const maxBitLength = descriptor.length * 8;\n  let count0 = 0;\n  let count1 = 0;\n  for (let i = 0; i < maxBitLength; i++) {\n    const bit = getBit(descriptor, i);\n    bools.push(bit);\n    if (bit) {\n      count1++;\n    } else {\n      count0++;\n    }\n    if (count1 > count0) {\n      i++;\n      if (i + 7 < maxBitLength) {\n        throw new Error(\"Invalid descriptor: too many bytes\");\n      }\n      for (; i < maxBitLength; i++) {\n        const bit = getBit(descriptor, i);\n        if (bit) {\n          throw new Error(\"Invalid descriptor: too many 1 bits\");\n        }\n      }\n      return bools;\n    }\n  }\n  throw new Error(\"Invalid descriptor: not enough 1 bits\");\n}\nexports.descriptorToBitlist = descriptorToBitlist;\nfunction nodeToCompactMultiProof(node, bitlist, bitIndex) {\n  if (bitlist[bitIndex]) {\n    return [node.root];\n  } else {\n    const left = nodeToCompactMultiProof(node.left, bitlist, bitIndex + 1);\n    const right = nodeToCompactMultiProof(node.right, bitlist, bitIndex + left.length * 2);\n    return [...left, ...right];\n  }\n}\nexports.nodeToCompactMultiProof = nodeToCompactMultiProof;\n/**\n * Create a Node given a validated bitlist, leaves, and a pointer into the bitlist and leaves\n *\n * Recursive definition\n */\nfunction compactMultiProofToNode(bitlist, leaves, pointer) {\n  if (bitlist[pointer.bitIndex++]) {\n    return node_1.LeafNode.fromRoot(leaves[pointer.leafIndex++]);\n  } else {\n    return new node_1.BranchNode(compactMultiProofToNode(bitlist, leaves, pointer), compactMultiProofToNode(bitlist, leaves, pointer));\n  }\n}\nexports.compactMultiProofToNode = compactMultiProofToNode;\nfunction createCompactMultiProof(rootNode, descriptor) {\n  return nodeToCompactMultiProof(rootNode, descriptorToBitlist(descriptor), 0);\n}\nexports.createCompactMultiProof = createCompactMultiProof;\nfunction createNodeFromCompactMultiProof(leaves, descriptor) {\n  const bools = descriptorToBitlist(descriptor);\n  if (bools.length !== leaves.length * 2 - 1) {\n    throw new Error(\"Invalid multiproof: invalid number of leaves\");\n  }\n  return compactMultiProofToNode(bools, leaves, {\n    bitIndex: 0,\n    leafIndex: 0\n  });\n}\nexports.createNodeFromCompactMultiProof = createNodeFromCompactMultiProof;","map":{"version":3,"names":["Object","defineProperty","exports","value","createNodeFromCompactMultiProof","createCompactMultiProof","compactMultiProofToNode","nodeToCompactMultiProof","descriptorToBitlist","computeDescriptor","gindex_1","require","node_1","util_1","indices","proofBitstrings","Set","pathBitstrings","leafIndex","leafBitstring","convertGindexToBitstring","add","branch","path","computeProofBitstrings","delete","pathIndex","branchIndex","allBitstringsSorted","Array","from","sort","a","b","localeCompare","descriptorBitstring","gindexBitstring","i","length","padStart","padEnd","descriptor","Uint8Array","Number","substring","getBit","bitlist","bitIndex","bit","byteIdx","Math","floor","byte","Error","bools","maxBitLength","count0","count1","push","node","root","left","right","leaves","pointer","LeafNode","fromRoot","BranchNode","rootNode"],"sources":["/hood3/node_modules/@chainsafe/persistent-merkle-tree/lib/proof/compactMulti.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeFromCompactMultiProof = exports.createCompactMultiProof = exports.compactMultiProofToNode = exports.nodeToCompactMultiProof = exports.descriptorToBitlist = exports.computeDescriptor = void 0;\nconst gindex_1 = require(\"../gindex\");\nconst node_1 = require(\"../node\");\nconst util_1 = require(\"./util\");\nfunction computeDescriptor(indices) {\n    // include all helper indices\n    const proofBitstrings = new Set();\n    const pathBitstrings = new Set();\n    for (const leafIndex of indices) {\n        const leafBitstring = gindex_1.convertGindexToBitstring(leafIndex);\n        proofBitstrings.add(leafBitstring);\n        const { branch, path } = util_1.computeProofBitstrings(leafBitstring);\n        path.delete(leafBitstring);\n        for (const pathIndex of path) {\n            pathBitstrings.add(pathIndex);\n        }\n        for (const branchIndex of branch) {\n            proofBitstrings.add(branchIndex);\n        }\n    }\n    for (const pathIndex of pathBitstrings) {\n        proofBitstrings.delete(pathIndex);\n    }\n    // sort gindex bitstrings in-order\n    const allBitstringsSorted = Array.from(proofBitstrings).sort((a, b) => a.localeCompare(b));\n    // convert gindex bitstrings into descriptor bitstring\n    let descriptorBitstring = \"\";\n    for (const gindexBitstring of allBitstringsSorted) {\n        for (let i = 0; i < gindexBitstring.length; i++) {\n            if (gindexBitstring[gindexBitstring.length - 1 - i] === \"1\") {\n                descriptorBitstring += \"1\".padStart(i + 1, \"0\");\n                break;\n            }\n        }\n    }\n    // append zero bits to byte-alignt\n    if (descriptorBitstring.length % 8 != 0) {\n        descriptorBitstring = descriptorBitstring.padEnd(8 - (descriptorBitstring.length % 8) + descriptorBitstring.length, \"0\");\n    }\n    // convert descriptor bitstring to bytes\n    const descriptor = new Uint8Array(descriptorBitstring.length / 8);\n    for (let i = 0; i < descriptor.length; i++) {\n        descriptor[i] = Number(\"0b\" + descriptorBitstring.substring(i * 8, (i + 1) * 8));\n    }\n    return descriptor;\n}\nexports.computeDescriptor = computeDescriptor;\nfunction getBit(bitlist, bitIndex) {\n    const bit = bitIndex % 8;\n    const byteIdx = Math.floor(bitIndex / 8);\n    const byte = bitlist[byteIdx];\n    switch (bit) {\n        case 0:\n            return (byte & 0b1000_0000) !== 0;\n        case 1:\n            return (byte & 0b0100_0000) !== 0;\n        case 2:\n            return (byte & 0b0010_0000) !== 0;\n        case 3:\n            return (byte & 0b0001_0000) !== 0;\n        case 4:\n            return (byte & 0b0000_1000) !== 0;\n        case 5:\n            return (byte & 0b0000_0100) !== 0;\n        case 6:\n            return (byte & 0b0000_0010) !== 0;\n        case 7:\n            return (byte & 0b0000_0001) !== 0;\n        default:\n            throw new Error(\"unreachable\");\n    }\n}\nfunction descriptorToBitlist(descriptor) {\n    const bools = [];\n    const maxBitLength = descriptor.length * 8;\n    let count0 = 0;\n    let count1 = 0;\n    for (let i = 0; i < maxBitLength; i++) {\n        const bit = getBit(descriptor, i);\n        bools.push(bit);\n        if (bit) {\n            count1++;\n        }\n        else {\n            count0++;\n        }\n        if (count1 > count0) {\n            i++;\n            if (i + 7 < maxBitLength) {\n                throw new Error(\"Invalid descriptor: too many bytes\");\n            }\n            for (; i < maxBitLength; i++) {\n                const bit = getBit(descriptor, i);\n                if (bit) {\n                    throw new Error(\"Invalid descriptor: too many 1 bits\");\n                }\n            }\n            return bools;\n        }\n    }\n    throw new Error(\"Invalid descriptor: not enough 1 bits\");\n}\nexports.descriptorToBitlist = descriptorToBitlist;\nfunction nodeToCompactMultiProof(node, bitlist, bitIndex) {\n    if (bitlist[bitIndex]) {\n        return [node.root];\n    }\n    else {\n        const left = nodeToCompactMultiProof(node.left, bitlist, bitIndex + 1);\n        const right = nodeToCompactMultiProof(node.right, bitlist, bitIndex + left.length * 2);\n        return [...left, ...right];\n    }\n}\nexports.nodeToCompactMultiProof = nodeToCompactMultiProof;\n/**\n * Create a Node given a validated bitlist, leaves, and a pointer into the bitlist and leaves\n *\n * Recursive definition\n */\nfunction compactMultiProofToNode(bitlist, leaves, pointer) {\n    if (bitlist[pointer.bitIndex++]) {\n        return node_1.LeafNode.fromRoot(leaves[pointer.leafIndex++]);\n    }\n    else {\n        return new node_1.BranchNode(compactMultiProofToNode(bitlist, leaves, pointer), compactMultiProofToNode(bitlist, leaves, pointer));\n    }\n}\nexports.compactMultiProofToNode = compactMultiProofToNode;\nfunction createCompactMultiProof(rootNode, descriptor) {\n    return nodeToCompactMultiProof(rootNode, descriptorToBitlist(descriptor), 0);\n}\nexports.createCompactMultiProof = createCompactMultiProof;\nfunction createNodeFromCompactMultiProof(leaves, descriptor) {\n    const bools = descriptorToBitlist(descriptor);\n    if (bools.length !== leaves.length * 2 - 1) {\n        throw new Error(\"Invalid multiproof: invalid number of leaves\");\n    }\n    return compactMultiProofToNode(bools, leaves, { bitIndex: 0, leafIndex: 0 });\n}\nexports.createNodeFromCompactMultiProof = createNodeFromCompactMultiProof;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}