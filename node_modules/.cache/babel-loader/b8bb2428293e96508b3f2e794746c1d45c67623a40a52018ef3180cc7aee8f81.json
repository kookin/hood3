{"ast":null,"code":"import { ChaCha20Poly1305 as ie } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as pn } from \"@stablelib/hkdf\";\nimport { randomBytes as ce } from \"@stablelib/random\";\nimport { SHA256 as mn, hash as ae } from \"@stablelib/sha256\";\nimport * as ue from \"@stablelib/x25519\";\nimport { toString as E, fromString as h, concat as de } from \"uint8arrays\";\nimport { detect as yn } from \"detect-browser\";\nimport { toMiliseconds as q, FIVE_MINUTES as le, fromMiliseconds as En } from \"@walletconnect/time\";\nimport { getDocument as hn, getNavigator as fe, getLocation as pe } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as vn } from \"@walletconnect/window-metadata\";\nimport * as $ from \"query-string\";\nimport { RELAY_JSONRPC as gn } from \"@walletconnect/relay-api\";\nconst D = \":\";\nfunction me(e) {\n  const [n, t] = e.split(D);\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction ye(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = e;\n  return [n, t].join(D);\n}\nfunction z(e) {\n  const [n, t, r] = e.split(D);\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction Ee(e) {\n  const {\n    namespace: n,\n    reference: t,\n    address: r\n  } = e;\n  return [n, t, r].join(D);\n}\nfunction B(e, n) {\n  const t = [];\n  return e.forEach(r => {\n    const o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction he(e) {\n  const {\n    address: n\n  } = z(e);\n  return n;\n}\nfunction ve(e) {\n  const {\n    namespace: n,\n    reference: t\n  } = z(e);\n  return ye({\n    namespace: n,\n    reference: t\n  });\n}\nfunction Nn(e, n) {\n  const {\n    namespace: t,\n    reference: r\n  } = me(n);\n  return Ee({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction bn(e) {\n  return B(e, he);\n}\nfunction ge(e) {\n  return B(e, ve);\n}\nfunction On(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...o.accounts);\n  }), t;\n}\nfunction Sn(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...ge(o.accounts));\n  }), t;\n}\nfunction In(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const t = [];\n  return Object.keys(e).forEach(r => {\n    if (n.length && !n.includes(r)) return;\n    const o = e[r];\n    t.push(...V(r, o));\n  }), t;\n}\nfunction V(e, n) {\n  return e.includes(\":\") ? [e] : n.chains || [];\n}\nconst M = e => e?.split(\":\"),\n  Ne = e => {\n    const n = e && M(e);\n    if (n) return n[3];\n  },\n  Pn = e => {\n    const n = e && M(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  be = e => {\n    const n = e && M(e);\n    if (n) return n.pop();\n  },\n  Tn = (e, n) => {\n    const t = `${e.domain} wants you to sign in with your Ethereum account:`,\n      r = be(n),\n      o = e.statement,\n      s = `URI: ${e.aud}`,\n      c = `Version: ${e.version}`,\n      d = `Chain ID: ${Ne(n)}`,\n      l = `Nonce: ${e.nonce}`,\n      i = `Issued At: ${e.iat}`,\n      u = e.resources && e.resources.length > 0 ? `Resources:\n${e.resources.map(a => `- ${a}`).join(`\n`)}` : void 0;\n    return [t, r, \"\", o, \"\", s, c, d, l, i, u].filter(a => a != null).join(`\n`);\n  },\n  G = \"base10\",\n  f = \"base16\",\n  K = \"base64pad\",\n  k = \"utf8\",\n  W = 0,\n  U = 1,\n  Rn = 0,\n  Oe = 1,\n  Y = 12,\n  J = 32;\nfunction An() {\n  const e = ue.generateKeyPair();\n  return {\n    privateKey: E(e.secretKey, f),\n    publicKey: E(e.publicKey, f)\n  };\n}\nfunction Un() {\n  const e = ce(J);\n  return E(e, f);\n}\nfunction _n(e, n) {\n  const t = ue.sharedKey(h(e, f), h(n, f)),\n    r = new pn(mn, t).expand(J);\n  return E(r, f);\n}\nfunction wn(e) {\n  const n = ae(h(e, f));\n  return E(n, f);\n}\nfunction jn(e) {\n  const n = ae(h(e, k));\n  return E(n, f);\n}\nfunction Se(e) {\n  return h(`${e}`, G);\n}\nfunction j(e) {\n  return Number(E(e, G));\n}\nfunction Cn(e) {\n  const n = Se(typeof e.type < \"u\" ? e.type : W);\n  if (j(n) === U && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  const t = typeof e.senderPublicKey < \"u\" ? h(e.senderPublicKey, f) : void 0,\n    r = typeof e.iv < \"u\" ? h(e.iv, f) : ce(Y),\n    o = new ie(h(e.symKey, f)).seal(r, h(e.message, k));\n  return Ie({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction $n(e) {\n  const n = new ie(h(e.symKey, f)),\n    {\n      sealed: t,\n      iv: r\n    } = Q(e.encoded),\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return E(o, k);\n}\nfunction Ie(e) {\n  if (j(e.type) === U) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return E(de([e.type, e.senderPublicKey, e.iv, e.sealed]), K);\n  }\n  return E(de([e.type, e.iv, e.sealed]), K);\n}\nfunction Q(e) {\n  const n = h(e, K),\n    t = n.slice(Rn, Oe),\n    r = Oe;\n  if (j(t) === U) {\n    const d = r + J,\n      l = d + Y,\n      i = n.slice(r, d),\n      u = n.slice(d, l),\n      a = n.slice(l);\n    return {\n      type: t,\n      sealed: a,\n      iv: u,\n      senderPublicKey: i\n    };\n  }\n  const o = r + Y,\n    s = n.slice(r, o),\n    c = n.slice(o);\n  return {\n    type: t,\n    sealed: c,\n    iv: s\n  };\n}\nfunction Dn(e, n) {\n  const t = Q(e);\n  return Pe({\n    type: j(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? E(t.senderPublicKey, f) : void 0,\n    receiverPublicKey: n?.receiverPublicKey\n  });\n}\nfunction Pe(e) {\n  const n = e?.type || W;\n  if (n === U) {\n    if (typeof e?.senderPublicKey > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof e?.receiverPublicKey > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e?.senderPublicKey,\n    receiverPublicKey: e?.receiverPublicKey\n  };\n}\nfunction Vn(e) {\n  return e.type === U && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar Mn = Object.defineProperty,\n  Te = Object.getOwnPropertySymbols,\n  Kn = Object.prototype.hasOwnProperty,\n  kn = Object.prototype.propertyIsEnumerable,\n  Re = (e, n, t) => n in e ? Mn(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Ae = (e, n) => {\n    for (var t in n || (n = {})) Kn.call(n, t) && Re(e, t, n[t]);\n    if (Te) for (var t of Te(n)) kn.call(n, t) && Re(e, t, n[t]);\n    return e;\n  };\nconst Ue = \"ReactNative\",\n  _ = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  L = \" \",\n  Ln = \":\",\n  _e = \"/\",\n  Z = 2,\n  xn = 1e3,\n  we = \"js\";\nfunction X() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction je() {\n  return !hn() && !!fe() && navigator.product === Ue;\n}\nfunction Ce() {\n  return !X() && !!fe();\n}\nfunction ee() {\n  return je() ? _.reactNative : X() ? _.node : Ce() ? _.browser : _.unknown;\n}\nfunction $e(e, n) {\n  let t = $.parse(e);\n  return t = Ae(Ae({}, t), n), e = $.stringify(t), e;\n}\nfunction Fn() {\n  return vn() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction Hn(e, n) {\n  var t;\n  const r = ee(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = pe()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction De() {\n  const e = yn();\n  if (e === null) return \"unknown\";\n  const n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Ve() {\n  var e;\n  const n = ee();\n  return n === _.browser ? [n, ((e = pe()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Me(e, n, t) {\n  const r = De(),\n    o = Ve();\n  return [[e, n].join(\"-\"), [we, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction qn(_ref) {\n  let {\n    protocol: e,\n    version: n,\n    relayUrl: t,\n    sdkVersion: r,\n    auth: o,\n    projectId: s,\n    useOnCloseEvent: c\n  } = _ref;\n  const d = t.split(\"?\"),\n    l = Me(e, n, r),\n    i = {\n      auth: o,\n      ua: l,\n      projectId: s,\n      useOnCloseEvent: c || void 0\n    },\n    u = $e(d[1] || \"\", i);\n  return d[0] + \"?\" + u;\n}\nfunction zn(e) {\n  let n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  const t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Bn(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(`Missing or invalid \"${n}\" param`);\n}\nfunction Ke(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Z;\n  return ke(e.split(_e), n);\n}\nfunction Gn(e) {\n  return Ke(e).join(L);\n}\nfunction b(e, n) {\n  return e.filter(t => n.includes(t)).length === e.length;\n}\nfunction ke(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Z;\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction Wn(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Yn(e) {\n  return new Map(Object.entries(e));\n}\nfunction Jn(e, n) {\n  const t = {};\n  return Object.keys(e).forEach(r => {\n    t[r] = n(e[r]);\n  }), t;\n}\nconst Qn = e => e;\nfunction Le(e) {\n  return e.trim().replace(/^\\w/, n => n.toUpperCase());\n}\nfunction Zn(e) {\n  return e.split(L).map(n => Le(n)).join(L);\n}\nfunction Xn() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : le;\n  let n = arguments.length > 1 ? arguments[1] : undefined;\n  const t = q(e || le);\n  let r, o, s;\n  return {\n    resolve: c => {\n      s && r && (clearTimeout(s), r(c));\n    },\n    reject: c => {\n      s && o && (clearTimeout(s), o(c));\n    },\n    done: () => new Promise((c, d) => {\n      s = setTimeout(() => {\n        d(new Error(n));\n      }, t), r = c, o = d;\n    })\n  };\n}\nfunction et(e, n, t) {\n  return new Promise(async (r, o) => {\n    const s = setTimeout(() => o(new Error(t)), n);\n    try {\n      const c = await e;\n      r(c);\n    } catch (c) {\n      o(c);\n    }\n    clearTimeout(s);\n  });\n}\nfunction ne(e, n) {\n  if (typeof n == \"string\" && n.startsWith(`${e}:`)) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return `topic:${n}`;\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return `id:${n}`;\n  }\n  throw new Error(`Unknown expirer target type: ${e}`);\n}\nfunction nt(e) {\n  return ne(\"topic\", e);\n}\nfunction tt(e) {\n  return ne(\"id\", e);\n}\nfunction rt(e) {\n  const [n, t] = e.split(\":\"),\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);\n  return r;\n}\nfunction ot(e, n) {\n  return En((n || Date.now()) + q(e));\n}\nfunction st(e) {\n  return Date.now() >= q(e);\n}\nfunction it(e, n) {\n  return `${e}${n ? `:${n}` : \"\"}`;\n}\nfunction O() {\n  let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return [...new Set([...e, ...n])];\n}\nconst xe = \"irn\";\nfunction ct(e) {\n  return e?.relay || {\n    protocol: xe\n  };\n}\nfunction at(e) {\n  const n = gn[e];\n  if (typeof n > \"u\") throw new Error(`Relay Protocol not supported: ${e}`);\n  return n;\n}\nvar ut = Object.defineProperty,\n  Fe = Object.getOwnPropertySymbols,\n  dt = Object.prototype.hasOwnProperty,\n  lt = Object.prototype.propertyIsEnumerable,\n  He = (e, n, t) => n in e ? ut(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  ft = (e, n) => {\n    for (var t in n || (n = {})) dt.call(n, t) && He(e, t, n[t]);\n    if (Fe) for (var t of Fe(n)) lt.call(n, t) && He(e, t, n[t]);\n    return e;\n  };\nfunction qe(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(o => {\n    if (o.startsWith(r)) {\n      const s = o.replace(r, \"\"),\n        c = e[o];\n      t[s] = c;\n    }\n  }), t;\n}\nfunction pt(e) {\n  const n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    c = $.parse(s);\n  return {\n    protocol: r,\n    topic: ze(o[0]),\n    version: parseInt(o[1], 10),\n    symKey: c.symKey,\n    relay: qe(c)\n  };\n}\nfunction ze(e) {\n  return e.startsWith(\"//\") ? e.substring(2) : e;\n}\nfunction Be(e) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  const t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(o => {\n    const s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction mt(e) {\n  return `${e.protocol}:${e.topic}@${e.version}?` + $.stringify(ft({\n    symKey: e.symKey\n  }, Be(e.relay)));\n}\nvar yt = Object.defineProperty,\n  Et = Object.defineProperties,\n  ht = Object.getOwnPropertyDescriptors,\n  Ge = Object.getOwnPropertySymbols,\n  vt = Object.prototype.hasOwnProperty,\n  gt = Object.prototype.propertyIsEnumerable,\n  We = (e, n, t) => n in e ? yt(e, n, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : e[n] = t,\n  Nt = (e, n) => {\n    for (var t in n || (n = {})) vt.call(n, t) && We(e, t, n[t]);\n    if (Ge) for (var t of Ge(n)) gt.call(n, t) && We(e, t, n[t]);\n    return e;\n  },\n  bt = (e, n) => Et(e, ht(n));\nfunction T(e) {\n  const n = [];\n  return e.forEach(t => {\n    const [r, o] = t.split(\":\");\n    n.push(`${r}:${o}`);\n  }), n;\n}\nfunction Ye(e) {\n  const n = [];\n  return Object.values(e).forEach(t => {\n    n.push(...T(t.accounts));\n  }), n;\n}\nfunction Je(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    T(r.accounts).includes(n) && t.push(...r.methods);\n  }), t;\n}\nfunction Qe(e, n) {\n  const t = [];\n  return Object.values(e).forEach(r => {\n    T(r.accounts).includes(n) && t.push(...r.events);\n  }), t;\n}\nfunction Ot(e, n) {\n  const t = sn(e, n);\n  if (t) throw new Error(t.message);\n  const r = {};\n  for (const [o, s] of Object.entries(e)) r[o] = {\n    methods: s.methods,\n    events: s.events,\n    chains: s.accounts.map(c => `${c.split(\":\")[0]}:${c.split(\":\")[1]}`)\n  };\n  return r;\n}\nfunction St(e) {\n  const {\n      proposal: {\n        requiredNamespaces: n,\n        optionalNamespaces: t = {}\n      },\n      supportedNamespaces: r\n    } = e,\n    o = re(n),\n    s = re(t),\n    c = {};\n  Object.keys(r).forEach(i => {\n    const u = r[i].chains,\n      a = r[i].methods,\n      g = r[i].events,\n      A = r[i].accounts;\n    c[i] = {\n      chains: u,\n      methods: a,\n      events: g,\n      accounts: A\n    };\n  });\n  const d = an(n, c, \"approve()\");\n  if (d) throw new Error(d.message);\n  const l = {};\n  return Object.keys(o).forEach(i => {\n    const u = r[i].chains.filter(v => {\n        var p, y;\n        return (y = (p = o[i]) == null ? void 0 : p.chains) == null ? void 0 : y.includes(v);\n      }),\n      a = r[i].methods.filter(v => {\n        var p, y;\n        return (y = (p = o[i]) == null ? void 0 : p.methods) == null ? void 0 : y.includes(v);\n      }),\n      g = r[i].events.filter(v => {\n        var p, y;\n        return (y = (p = o[i]) == null ? void 0 : p.events) == null ? void 0 : y.includes(v);\n      }),\n      A = u.map(v => r[i].accounts.filter(p => p.includes(`${v}:`))).flat();\n    l[i] = {\n      chains: u,\n      methods: a,\n      events: g,\n      accounts: A\n    };\n  }), Object.keys(s).forEach(i => {\n    var u, a, g, A, v, p;\n    if (!r[i]) return;\n    const y = (a = (u = s[i]) == null ? void 0 : u.chains) == null ? void 0 : a.filter(I => r[i].chains.includes(I)),\n      dn = r[i].methods.filter(I => {\n        var P, w;\n        return (w = (P = s[i]) == null ? void 0 : P.methods) == null ? void 0 : w.includes(I);\n      }),\n      ln = r[i].events.filter(I => {\n        var P, w;\n        return (w = (P = s[i]) == null ? void 0 : P.events) == null ? void 0 : w.includes(I);\n      }),\n      fn = y?.map(I => r[i].accounts.filter(P => P.includes(I))).flat();\n    l[i] = {\n      chains: O((g = l[i]) == null ? void 0 : g.chains, y),\n      methods: O((A = l[i]) == null ? void 0 : A.methods, dn),\n      events: O((v = l[i]) == null ? void 0 : v.events, ln),\n      accounts: O((p = l[i]) == null ? void 0 : p.accounts, fn)\n    };\n  }), l;\n}\nfunction te(e) {\n  return e.includes(\":\");\n}\nfunction Ze(e) {\n  return te(e) ? e.split(\":\")[0] : e;\n}\nfunction re(e) {\n  var n, t, r;\n  const o = {};\n  if (!x(e)) return o;\n  for (const [s, c] of Object.entries(e)) {\n    const d = te(s) ? [s] : c.chains,\n      l = c.methods || [],\n      i = c.events || [],\n      u = Ze(s);\n    o[u] = bt(Nt({}, o[u]), {\n      chains: O(d, (n = o[u]) == null ? void 0 : n.chains),\n      methods: O(l, (t = o[u]) == null ? void 0 : t.methods),\n      events: O(i, (r = o[u]) == null ? void 0 : r.events)\n    });\n  }\n  return o;\n}\nconst It = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Pt = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction N(e, n) {\n  const {\n    message: t,\n    code: r\n  } = Pt[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction R(e, n) {\n  const {\n    message: t,\n    code: r\n  } = It[e];\n  return {\n    message: n ? `${t} ${n}` : t,\n    code: r\n  };\n}\nfunction C(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction x(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction S(e) {\n  return typeof e > \"u\";\n}\nfunction m(e, n) {\n  return n && S(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\nfunction F(e, n) {\n  return n && S(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction Tt(e, n) {\n  const {\n      requiredNamespaces: t\n    } = n,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  let s = !0;\n  return b(o, r) ? (r.forEach(c => {\n    const {\n        accounts: d,\n        methods: l,\n        events: i\n      } = e.namespaces[c],\n      u = T(d),\n      a = t[c];\n    (!b(V(c, a), u) || !b(a.methods, l) || !b(a.events, i)) && (s = !1);\n  }), s) : !1;\n}\nfunction H(e) {\n  return m(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction Xe(e) {\n  if (m(e, !1) && e.includes(\":\")) {\n    const n = e.split(\":\");\n    if (n.length === 3) {\n      const t = n[0] + \":\" + n[1];\n      return !!n[2] && H(t);\n    }\n  }\n  return !1;\n}\nfunction Rt(e) {\n  if (m(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch {\n    return !1;\n  }\n  return !1;\n}\nfunction At(e) {\n  var n;\n  return (n = e?.proposer) == null ? void 0 : n.publicKey;\n}\nfunction Ut(e) {\n  return e?.topic;\n}\nfunction _t(e, n) {\n  let t = null;\n  return m(e?.publicKey, !1) || (t = N(\"MISSING_OR_INVALID\", `${n} controller public key should be a string`)), t;\n}\nfunction oe(e) {\n  let n = !0;\n  return C(e) ? e.length && (n = e.every(t => m(t, !1))) : n = !1, n;\n}\nfunction en(e, n, t) {\n  let r = null;\n  return C(n) ? n.forEach(o => {\n    r || (!H(o) || !o.includes(e)) && (r = R(\"UNSUPPORTED_CHAINS\", `${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`));\n  }) : r = R(\"UNSUPPORTED_CHAINS\", `${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`), r;\n}\nfunction nn(e, n) {\n  let t = null;\n  return Object.entries(e).forEach(_ref2 => {\n    let [r, o] = _ref2;\n    if (t) return;\n    const s = en(r, V(r, o), `${n} requiredNamespace`);\n    s && (t = s);\n  }), t;\n}\nfunction tn(e, n) {\n  let t = null;\n  return C(e) ? e.forEach(r => {\n    t || Xe(r) || (t = R(\"UNSUPPORTED_ACCOUNTS\", `${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`));\n  }) : t = R(\"UNSUPPORTED_ACCOUNTS\", `${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`), t;\n}\nfunction rn(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = tn(r?.accounts, `${n} namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction on(e, n) {\n  let t = null;\n  return oe(e?.methods) ? oe(e?.events) || (t = R(\"UNSUPPORTED_EVENTS\", `${n}, events should be an array of strings or empty array for no events`)) : t = R(\"UNSUPPORTED_METHODS\", `${n}, methods should be an array of strings or empty array for no methods`), t;\n}\nfunction se(e, n) {\n  let t = null;\n  return Object.values(e).forEach(r => {\n    if (t) return;\n    const o = on(r, `${n}, namespace`);\n    o && (t = o);\n  }), t;\n}\nfunction wt(e, n, t) {\n  let r = null;\n  if (e && x(e)) {\n    const o = se(e, n);\n    o && (r = o);\n    const s = nn(e, n);\n    s && (r = s);\n  } else r = N(\"MISSING_OR_INVALID\", `${n}, ${t} should be an object with data`);\n  return r;\n}\nfunction sn(e, n) {\n  let t = null;\n  if (e && x(e)) {\n    const r = se(e, n);\n    r && (t = r);\n    const o = rn(e, n);\n    o && (t = o);\n  } else t = N(\"MISSING_OR_INVALID\", `${n}, namespaces should be an object with data`);\n  return t;\n}\nfunction cn(e) {\n  return m(e.protocol, !0);\n}\nfunction jt(e, n) {\n  let t = !1;\n  return n && !e ? t = !0 : e && C(e) && e.length && e.forEach(r => {\n    t = cn(r);\n  }), t;\n}\nfunction Ct(e) {\n  return typeof e == \"number\";\n}\nfunction $t(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction Dt(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !F(e.code, !1) || !e.message || !m(e.message, !1));\n}\nfunction Vt(e) {\n  return !(S(e) || !m(e.method, !1));\n}\nfunction Mt(e) {\n  return !(S(e) || S(e.result) && S(e.error) || !F(e.id, !1) || !m(e.jsonrpc, !1));\n}\nfunction Kt(e) {\n  return !(S(e) || !m(e.name, !1));\n}\nfunction kt(e, n) {\n  return !(!H(n) || !Ye(e).includes(n));\n}\nfunction Lt(e, n, t) {\n  return m(t, !1) ? Je(e, n).includes(t) : !1;\n}\nfunction xt(e, n, t) {\n  return m(t, !1) ? Qe(e, n).includes(t) : !1;\n}\nfunction an(e, n, t) {\n  let r = null;\n  const o = Ft(e),\n    s = Ht(n),\n    c = Object.keys(o),\n    d = Object.keys(s),\n    l = un(Object.keys(e)),\n    i = un(Object.keys(n)),\n    u = l.filter(a => !i.includes(a));\n  return u.length && (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${u.toString()}\n      Received: ${Object.keys(n).toString()}`)), b(c, d) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces chains don't satisfy required namespaces.\n      Required: ${c.toString()}\n      Approved: ${d.toString()}`)), Object.keys(n).forEach(a => {\n    if (!a.includes(\":\") || r) return;\n    const g = T(n[a].accounts);\n    g.includes(a) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces accounts don't satisfy namespace accounts for ${a}\n        Required: ${a}\n        Approved: ${g.toString()}`));\n  }), c.forEach(a => {\n    r || (b(o[a].methods, s[a].methods) ? b(o[a].events, s[a].events) || (r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces events don't satisfy namespace events for ${a}`)) : r = N(\"NON_CONFORMING_NAMESPACES\", `${t} namespaces methods don't satisfy namespace methods for ${a}`));\n  }), r;\n}\nfunction Ft(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    var r;\n    t.includes(\":\") ? n[t] = e[t] : (r = e[t].chains) == null || r.forEach(o => {\n      n[o] = {\n        methods: e[t].methods,\n        events: e[t].events\n      };\n    });\n  }), n;\n}\nfunction un(e) {\n  return [...new Set(e.map(n => n.includes(\":\") ? n.split(\":\")[0] : n))];\n}\nfunction Ht(e) {\n  const n = {};\n  return Object.keys(e).forEach(t => {\n    if (t.includes(\":\")) n[t] = e[t];else {\n      const r = T(e[t].accounts);\n      r?.forEach(o => {\n        n[o] = {\n          accounts: e[t].accounts.filter(s => s.includes(`${o}:`)),\n          methods: e[t].methods,\n          events: e[t].events\n        };\n      });\n    }\n  }), n;\n}\nfunction qt(e, n) {\n  return F(e, !1) && e <= n.max && e >= n.min;\n}\nexport { G as BASE10, f as BASE16, K as BASE64, Ln as COLON, Z as DEFAULT_DEPTH, L as EMPTY_SPACE, _ as ENV_MAP, xn as ONE_THOUSAND, Ue as REACT_NATIVE_PRODUCT, xe as RELAYER_DEFAULT_PROTOCOL, we as SDK_TYPE, _e as SLASH, W as TYPE_0, U as TYPE_1, k as UTF8, $e as appendToQueryString, Bn as assertType, St as buildApprovedNamespaces, ot as calcExpiry, Zn as capitalize, Le as capitalizeWord, Xn as createDelayedPromise, et as createExpiringPromise, j as decodeTypeByte, $n as decrypt, _n as deriveSymKey, Q as deserialize, Se as encodeTypeByte, Cn as encrypt, it as engineEvent, Qn as enumify, Ee as formatAccountId, Nn as formatAccountWithChain, ye as formatChainId, ne as formatExpirerTarget, tt as formatIdTarget, Tn as formatMessage, Gn as formatMessageContext, Be as formatRelayParams, qn as formatRelayRpcUrl, nt as formatTopicTarget, Me as formatUA, mt as formatUri, An as generateKeyPair, Un as generateRandomBytes32, T as getAccountsChains, On as getAccountsFromNamespaces, he as getAddressFromAccount, bn as getAddressesFromAccounts, Fn as getAppMetadata, ve as getChainFromAccount, ge as getChainsFromAccounts, V as getChainsFromNamespace, Sn as getChainsFromNamespaces, In as getChainsFromRequiredNamespaces, be as getDidAddress, M as getDidAddressSegments, Ne as getDidChainId, ee as getEnvironment, zn as getHttpUrl, N as getInternalError, Ve as getJavascriptID, De as getJavascriptOS, ke as getLastItems, Pn as getNamespacedDidChainId, Ye as getNamespacesChains, Qe as getNamespacesEventsForChainId, Je as getNamespacesMethodsForChainId, Hn as getRelayClientMetadata, at as getRelayProtocolApi, ct as getRelayProtocolName, Ot as getRequiredNamespacesFromNamespaces, R as getSdkError, B as getUniqueValues, b as hasOverlap, wn as hashKey, jn as hashMessage, Ce as isBrowser, te as isCaipNamespace, an as isConformingNamespaces, st as isExpired, X as isNode, At as isProposalStruct, je as isReactNative, Tt as isSessionCompatible, Ut as isSessionStruct, Vn as isTypeOneEnvelope, S as isUndefined, Xe as isValidAccountId, tn as isValidAccounts, on as isValidActions, C as isValidArray, H as isValidChainId, en as isValidChains, _t as isValidController, Dt as isValidErrorReason, Kt as isValidEvent, Ct as isValidId, rn as isValidNamespaceAccounts, se as isValidNamespaceActions, nn as isValidNamespaceChains, oe as isValidNamespaceMethodsOrEvents, sn as isValidNamespaces, kt as isValidNamespacesChainId, xt as isValidNamespacesEvent, Lt as isValidNamespacesRequest, F as isValidNumber, x as isValidObject, $t as isValidParams, cn as isValidRelay, jt as isValidRelays, Vt as isValidRequest, qt as isValidRequestExpiry, wt as isValidRequiredNamespaces, Mt as isValidResponse, m as isValidString, Rt as isValidUrl, Jn as mapEntries, Wn as mapToObj, O as mergeArrays, re as normalizeNamespaces, Yn as objToMap, z as parseAccountId, me as parseChainId, Ke as parseContextNames, rt as parseExpirerTarget, Ze as parseNamespaceKey, qe as parseRelayParams, ze as parseTopic, pt as parseUri, Ie as serialize, Dn as validateDecoding, Pe as validateEncoding };","map":{"version":3,"names":[],"sources":["/hood3/node_modules/@walletconnect/utils/src/caip.ts","/hood3/node_modules/@walletconnect/utils/src/cacao.ts","/hood3/node_modules/@walletconnect/utils/src/crypto.ts","/hood3/node_modules/@walletconnect/utils/src/misc.ts","/hood3/node_modules/@walletconnect/utils/src/relay.ts","/hood3/node_modules/@walletconnect/utils/src/uri.ts","/hood3/node_modules/@walletconnect/utils/src/namespaces.ts","/hood3/node_modules/@walletconnect/utils/src/errors.ts","/hood3/node_modules/@walletconnect/utils/src/validators.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","export interface CacaoPayload {\n  iss: string;\n  domain: string;\n  aud: string;\n  version: string;\n  nonce: string;\n  iat: string;\n  nbf?: string;\n  exp?: string;\n  statement?: string;\n  requestId?: string;\n  resources?: string[];\n}\n\nexport interface CacaoHeader {\n  t: \"eip4361\";\n}\n\nexport interface CacaoSignature {\n  t: \"eip191\" | \"eip1271\";\n  s: string;\n  m?: string;\n}\n\nexport interface Cacao {\n  h: CacaoHeader;\n  p: CacaoPayload;\n  s: CacaoSignature;\n}\n\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[3];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport const formatMessage = (cacao: CacaoPayload, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n  const statement = cacao.statement;\n  const uri = `URI: ${cacao.aud}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const resources =\n    cacao.resources && cacao.resources.length > 0\n      ? `Resources:\\n${cacao.resources.map((resource) => `- ${resource}`).join(\"\\n\")}`\n      : undefined;\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n","import { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { HKDF } from \"@stablelib/hkdf\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { hash, SHA256 } from \"@stablelib/sha256\";\nimport * as x25519 from \"@stablelib/x25519\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { concat, fromString, toString } from \"uint8arrays\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const keyPair = x25519.generateKeyPair();\n  return {\n    privateKey: toString(keyPair.secretKey, BASE16),\n    publicKey: toString(keyPair.publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.sharedKey(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n  );\n  const hkdf = new HKDF(SHA256, sharedKey);\n  const symKey = hkdf.expand(KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = hash(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const sealed = box.seal(iv, fromString(params.message, UTF8));\n  return serialize({ type, sealed, iv, senderPublicKey });\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const { sealed, iv } = deserialize(params.encoded);\n  const message = box.open(iv, sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      BASE64,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), BASE64);\n}\n\nexport function deserialize(encoded: string): CryptoTypes.EncodingParams {\n  const bytes = fromString(encoded, BASE64);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize(encoded);\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport * as qs from \"query-string\";\n\n// -- constants -----------------------------------------//\n\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(queryString: string, newQueryParams: any): string {\n  let queryParams = qs.parse(queryString);\n\n  queryParams = { ...queryParams, ...newQueryParams };\n\n  queryString = qs.stringify(queryParams);\n\n  return queryString;\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n  useOnCloseEvent,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = { auth, ua, projectId, useOnCloseEvent: useOnCloseEvent || undefined };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>(\n  expiry: number = FIVE_MINUTES,\n  expireErrorMessage?: string,\n) {\n  const timeout = toMiliseconds(expiry || FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      cacheTimeout = setTimeout(() => {\n        promiseReject(new Error(expireErrorMessage));\n      }, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\nexport function createExpiringPromise<T>(\n  promise: Promise<T>,\n  expiry: number,\n  expireErrorMessage?: string,\n) {\n  return new Promise(async (resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error(expireErrorMessage)), expiry);\n    try {\n      const result = await promise;\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n    clearTimeout(timeout);\n  });\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return Date.now() >= toMiliseconds(expiry);\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n\nexport function mergeArrays<T>(a: T[] = [], b: T[] = []): T[] {\n  return [...new Set([...a, ...b])];\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import * as qs from \"query-string\";\nimport { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const queryParams = qs.parse(queryString);\n  const result = {\n    protocol,\n    topic: parseTopic(requiredValues[0]),\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n  };\n  return result;\n}\n\nexport function parseTopic(topic: string): string {\n  return topic.startsWith(\"//\") ? topic.substring(2) : topic;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const k = prefix + delimiter + key;\n    if (relay[key]) {\n      params[k] = relay[key];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  return (\n    `${params.protocol}:${params.topic}@${params.version}?` +\n    qs.stringify({\n      symKey: params.symKey,\n      ...formatRelayParams(params.relay),\n    })\n  );\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { mergeArrays } from \"./misc\";\nimport { isConformingNamespaces, isValidNamespaces, isValidObject } from \"./validators\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n\nexport type BuildApprovedNamespacesParams = {\n  proposal: ProposalTypes.Struct;\n  supportedNamespaces: Record<\n    string,\n    { chains: string[]; methods: string[]; events: string[]; accounts: string[] }\n  >;\n};\n\n/**\n * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.\n * It takes required & optional namespaces provided in the session proposal\n * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object\n * @param {BuildApprovedNamespacesParams} params\n * @returns {SessionTypes.Namespaces}\n */\nexport function buildApprovedNamespaces(\n  params: BuildApprovedNamespacesParams,\n): SessionTypes.Namespaces {\n  const {\n    proposal: { requiredNamespaces, optionalNamespaces = {} },\n    supportedNamespaces,\n  } = params;\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  // build approved namespaces\n  const namespaces = {};\n  Object.keys(supportedNamespaces).forEach((namespace) => {\n    const supportedChains = supportedNamespaces[namespace].chains;\n    const supportedMethods = supportedNamespaces[namespace].methods;\n    const supportedEvents = supportedNamespaces[namespace].events;\n    const supportedAccounts = supportedNamespaces[namespace].accounts;\n\n    namespaces[namespace] = {\n      chains: supportedChains,\n      methods: supportedMethods,\n      events: supportedEvents,\n      accounts: supportedAccounts,\n    };\n  });\n\n  // verify all required namespaces are supported\n  const err = isConformingNamespaces(requiredNamespaces, namespaces, \"approve()\");\n  if (err) throw new Error(err.message);\n\n  const approvedNamespaces = {};\n\n  // assign accounts for the required namespaces\n  Object.keys(normalizedRequired).forEach((requiredNamespace) => {\n    const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>\n      normalizedRequired[requiredNamespace]?.chains?.includes(chain),\n    );\n    const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>\n      normalizedRequired[requiredNamespace]?.methods?.includes(method),\n    );\n    const events = supportedNamespaces[requiredNamespace].events.filter((event) =>\n      normalizedRequired[requiredNamespace]?.events?.includes(event),\n    );\n\n    const accounts = chains\n      .map((chain: string) =>\n        supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[requiredNamespace] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  });\n\n  // add optional namespaces\n  Object.keys(normalizedOptional).forEach((optionalNamespace) => {\n    if (!supportedNamespaces[optionalNamespace]) return;\n\n    const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>\n      supportedNamespaces[optionalNamespace].chains.includes(chain),\n    );\n    const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>\n      normalizedOptional[optionalNamespace]?.methods?.includes(method),\n    );\n    const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>\n      normalizedOptional[optionalNamespace]?.events?.includes(event),\n    );\n\n    const accountsToAdd = chainsToAdd\n      ?.map((chain: string) =>\n        supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>\n          account.includes(chain),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[optionalNamespace] = {\n      chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),\n      methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),\n      events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),\n      accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),\n    };\n  });\n\n  return approvedNamespaces;\n}\n\nexport function isCaipNamespace(namespace: string): boolean {\n  return namespace.includes(\":\");\n}\n\nexport function parseNamespaceKey(namespace: string) {\n  return isCaipNamespace(namespace) ? namespace.split(\":\")[0] : namespace;\n}\n\n/**\n * Converts\n * ```\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * ```\n * into\n * ```\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *```\n */\nexport function normalizeNamespaces(\n  namespaces: ProposalTypes.RequiredNamespaces,\n): ProposalTypes.RequiredNamespaces {\n  const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n  }\n  return normalizedNamespaces;\n}\n","/**\n * Types\n */\ntype SdkErrorKey = keyof typeof SDK_ERRORS;\ntype InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nconst SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nconst INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { hasOverlap } from \"./misc\";\nimport { getChainsFromNamespace } from \"./caip\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n    if (\n      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  if (isValidString(value, false)) {\n    try {\n      const url = new URL(value);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(chains)) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain) || !chain.includes(key)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains ${chains} should be an array of strings conforming to \"namespace:chainId\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(\n      key,\n      getChainsFromNamespace(key, namespace),\n      `${method} requiredNamespace`,\n    );\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, ${type} should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n\n  const parsedRequired = parseNamespaces(requiredNamespaces);\n  const parsedApproved = parseApprovedNamespaces(namespaces);\n  const requiredChains = Object.keys(parsedRequired);\n  const approvedChains = Object.keys(parsedApproved);\n\n  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));\n  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));\n  const missingRequiredNamespaces = uniqueRequired.filter(\n    (namespace) => !uniqueApproved.includes(namespace),\n  );\n\n  if (missingRequiredNamespaces.length) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${missingRequiredNamespaces.toString()}\n      Received: ${Object.keys(namespaces).toString()}`,\n    );\n  }\n\n  if (!hasOverlap(requiredChains, approvedChains)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces chains don't satisfy required namespaces.\n      Required: ${requiredChains.toString()}\n      Approved: ${approvedChains.toString()}`,\n    );\n  }\n\n  // validate inline defined chains with approved accounts\n  Object.keys(namespaces).forEach((chain) => {\n    if (!chain.includes(\":\")) return;\n    if (error) return;\n    const chains = getAccountsChains(namespaces[chain].accounts);\n    if (!chains.includes(chain)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}\n        Required: ${chain}\n        Approved: ${chains.toString()}`,\n      );\n    }\n  });\n\n  requiredChains.forEach((chain) => {\n    if (error) return;\n\n    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,\n      );\n    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces events don't satisfy namespace events for ${chain}`,\n      );\n    }\n  });\n\n  return error;\n}\n\nfunction parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    // e.g. `eip155:1`\n    const isInlineChainDefinition = key.includes(\":\");\n\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      namespaces[key].chains?.forEach((chain) => {\n        parsed[chain] = {\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nfunction filterDuplicateNamespaces(namespaces: string[]) {\n  return [\n    ...new Set(\n      namespaces.map((namespace) =>\n        namespace.includes(\":\") ? namespace.split(\":\")[0] : namespace,\n      ),\n    ),\n  ];\n}\n\nfunction parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    const isInlineChainDefinition = key.includes(\":\");\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      const chains = getAccountsChains(namespaces[key].accounts);\n      chains?.forEach((chain) => {\n        parsed[chain] = {\n          accounts: namespaces[key].accounts.filter((account: string) =>\n            account.includes(`${chain}:`),\n          ),\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n"],"mappings":""},"metadata":{},"sourceType":"module","externalDependencies":[]}