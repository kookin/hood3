{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderContainerTypeName = exports.precomputeJsonKey = exports.ContainerType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst composite_1 = require(\"./composite\");\nconst container_1 = require(\"../view/container\");\nconst container_2 = require(\"../viewDU/container\");\nconst strings_1 = require(\"../util/strings\");\n/**\n * Container: ordered heterogeneous collection of values\n * - Notation: Custom name per instance\n */\nclass ContainerType extends composite_1.CompositeType {\n  constructor(fields, opts) {\n    super(opts?.cachePermanentRootStruct);\n    this.fields = fields;\n    this.opts = opts;\n    this.isList = false;\n    this.isViewMutable = true;\n    // Render detailed typeName. Consumers should overwrite since it can get long\n    this.typeName = opts?.typeName ?? renderContainerTypeName(fields);\n    this.maxChunkCount = Object.keys(fields).length;\n    this.depth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    // Precalculated data for faster serdes\n    this.fieldsEntries = [];\n    for (const fieldName of Object.keys(fields)) {\n      this.fieldsEntries.push({\n        fieldName,\n        fieldType: this.fields[fieldName],\n        jsonKey: precomputeJsonKey(fieldName, opts?.casingMap, opts?.jsonCase),\n        gindex: persistent_merkle_tree_1.toGindex(this.depth, BigInt(this.fieldsEntries.length))\n      });\n    }\n    if (this.fieldsEntries.length === 0) {\n      throw Error(\"Container must have > 0 fields\");\n    }\n    // Precalculate for Proofs API\n    this.fieldsGindex = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      this.fieldsGindex[this.fieldsEntries[i].fieldName] = persistent_merkle_tree_1.toGindex(this.depth, BigInt(i));\n    }\n    // To resolve JSON paths in fieldName notation and jsonKey notation\n    this.jsonKeyToFieldName = {};\n    for (const {\n      fieldName,\n      jsonKey\n    } of this.fieldsEntries) {\n      this.jsonKeyToFieldName[jsonKey] = fieldName;\n    }\n    const {\n      minLen,\n      maxLen,\n      fixedSize\n    } = precomputeSizes(fields);\n    this.minSize = minLen;\n    this.maxSize = maxLen;\n    this.fixedSize = fixedSize;\n    const {\n      isFixedLen,\n      fieldRangesFixedLen,\n      variableOffsetsPosition,\n      fixedEnd\n    } = precomputeSerdesData(fields);\n    this.isFixedLen = isFixedLen;\n    this.fieldRangesFixedLen = fieldRangesFixedLen;\n    this.variableOffsetsPosition = variableOffsetsPosition;\n    this.fixedEnd = fixedEnd;\n    // TODO: This options are necessary for ContainerNodeStruct to override this.\n    // Refactor this constructor to allow customization without pollutin the options\n    this.TreeView = opts?.getContainerTreeViewClass?.(this) ?? container_1.getContainerTreeViewClass(this);\n    this.TreeViewDU = opts?.getContainerTreeViewDUClass?.(this) ?? container_2.getContainerTreeViewDUClass(this);\n  }\n  static named(fields, opts) {\n    return new (named_1.namedClass(ContainerType, opts.typeName))(fields, opts);\n  }\n  defaultValue() {\n    const value = {};\n    for (const {\n      fieldName,\n      fieldType\n    } of this.fieldsEntries) {\n      value[fieldName] = fieldType.defaultValue();\n    }\n    return value;\n  }\n  getView(tree) {\n    return new this.TreeView(this, tree);\n  }\n  getViewDU(node, cache) {\n    return new this.TreeViewDU(this, node, cache);\n  }\n  cacheOfViewDU(view) {\n    return view.cache;\n  }\n  commitView(view) {\n    return view.node;\n  }\n  commitViewDU(view) {\n    view.commit();\n    return view.node;\n  }\n  // Serialization + deserialization\n  // -------------------------------\n  // Containers can mix fixed length and variable length data.\n  //\n  // Fixed part                         Variable part\n  // [field1 offset][field2 data       ][field1 data               ]\n  // [0x000000c]    [0xaabbaabbaabbaabb][0xffffffffffffffffffffffff]\n  value_serializedSize(value) {\n    let totalSize = 0;\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      // Offset (4 bytes) + size\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.value_serializedSize(value[fieldName]) : fieldType.fixedSize;\n    }\n    return totalSize;\n  }\n  value_serializeToBytes(output, offset, value) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4;\n        // write serialized element to variable section\n        variableIndex = fieldType.value_serializeToBytes(output, variableIndex, value[fieldName]);\n      } else {\n        fixedIndex = fieldType.value_serializeToBytes(output, fixedIndex, value[fieldName]);\n      }\n    }\n    return variableIndex;\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const value = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      value[fieldName] = fieldType.value_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n    return value;\n  }\n  tree_serializedSize(node) {\n    let totalSize = 0;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i];\n      // Offset (4 bytes) + size\n      totalSize += fieldType.fixedSize === null ? 4 + fieldType.tree_serializedSize(node) : fieldType.fixedSize;\n    }\n    return totalSize;\n  }\n  tree_serializeToBytes(output, offset, node) {\n    let fixedIndex = offset;\n    let variableIndex = offset + this.fixedEnd;\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(node, this.depth, 0, this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const node = nodes[i];\n      if (fieldType.fixedSize === null) {\n        // write offset\n        output.dataView.setUint32(fixedIndex, variableIndex - offset, true);\n        fixedIndex += 4;\n        // write serialized element to variable section\n        variableIndex = fieldType.tree_serializeToBytes(output, variableIndex, node);\n      } else {\n        fixedIndex = fieldType.tree_serializeToBytes(output, fixedIndex, node);\n      }\n    }\n    return variableIndex;\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const fieldRanges = this.getFieldRanges(data.dataView, start, end);\n    const nodes = new Array(this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldRange = fieldRanges[i];\n      nodes[i] = fieldType.tree_deserializeFromBytes(data, start + fieldRange.start, start + fieldRange.end);\n    }\n    return persistent_merkle_tree_1.subtreeFillToContents(nodes, this.depth);\n  }\n  // Merkleization\n  getRoots(struct) {\n    const roots = new Array(this.fieldsEntries.length);\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      roots[i] = fieldType.hashTreeRoot(struct[fieldName]);\n    }\n    return roots;\n  }\n  // Proofs\n  // getPropertyGindex\n  // getPropertyType\n  // tree_getLeafGindices\n  getPropertyGindex(prop) {\n    const gindex = this.fieldsGindex[prop] ?? this.fieldsGindex[this.jsonKeyToFieldName[prop]];\n    if (gindex === undefined) throw Error(`Unknown container property ${prop}`);\n    return gindex;\n  }\n  getPropertyType(prop) {\n    const type = this.fields[prop] ?? this.fields[this.jsonKeyToFieldName[prop]];\n    if (type === undefined) throw Error(`Unknown container property ${prop}`);\n    return type;\n  }\n  getIndexProperty(index) {\n    if (index >= this.fieldsEntries.length) {\n      return null;\n    }\n    return this.fieldsEntries[index].fieldName;\n  }\n  tree_getLeafGindices(rootGindex, rootNode) {\n    const gindices = [];\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      const fieldGindex = this.fieldsGindex[fieldName];\n      const fieldGindexFromRoot = persistent_merkle_tree_1.concatGindices([rootGindex, fieldGindex]);\n      if (fieldType.isBasic) {\n        gindices.push(fieldGindexFromRoot);\n      } else {\n        const compositeType = fieldType;\n        if (fieldType.fixedSize === null) {\n          if (!rootNode) {\n            throw new Error(\"variable type requires tree argument to get leaves\");\n          }\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot, persistent_merkle_tree_1.getNode(rootNode, fieldGindex)));\n        } else {\n          gindices.push(...compositeType.tree_getLeafGindices(fieldGindexFromRoot));\n        }\n      }\n    }\n    return gindices;\n  }\n  // JSON\n  fromJson(json) {\n    if (typeof json !== \"object\") {\n      throw Error(\"JSON must be of type object\");\n    }\n    if (json === null) {\n      throw Error(\"JSON must not be null\");\n    }\n    const value = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      const jsonValue = json[jsonKey];\n      if (jsonValue === undefined) {\n        throw Error(`JSON expected key ${jsonKey} is undefined`);\n      }\n      value[fieldName] = fieldType.fromJson(jsonValue);\n    }\n    return value;\n  }\n  toJson(value) {\n    const json = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType,\n        jsonKey\n      } = this.fieldsEntries[i];\n      json[jsonKey] = fieldType.toJson(value[fieldName]);\n    }\n    return json;\n  }\n  clone(value) {\n    const newValue = {};\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      newValue[fieldName] = fieldType.clone(value[fieldName]);\n    }\n    return newValue;\n  }\n  equals(a, b) {\n    for (let i = 0; i < this.fieldsEntries.length; i++) {\n      const {\n        fieldName,\n        fieldType\n      } = this.fieldsEntries[i];\n      if (!fieldType.equals(a[fieldName], b[fieldName])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Deserializer helper: Returns the bytes ranges of all fields, both variable and fixed size.\n   * Fields may not be contiguous in the serialized bytes, so the returned ranges are [start, end].\n   * - For fixed size fields re-uses the pre-computed values this.fieldRangesFixedLen\n   * - For variable size fields does a first pass over the fixed section to read offsets\n   */\n  getFieldRanges(data, start, end) {\n    if (this.variableOffsetsPosition.length === 0) {\n      // Validate fixed length container\n      const size = end - start;\n      if (size !== this.fixedEnd) {\n        throw Error(`${this.typeName} size ${size} not equal fixed size ${this.fixedEnd}`);\n      }\n      return this.fieldRangesFixedLen;\n    }\n    // Read offsets in one pass\n    const offsets = readVariableOffsets(data, start, end, this.fixedEnd, this.variableOffsetsPosition);\n    offsets.push(end - start); // The offsets are relative to the start\n    // Merge fieldRangesFixedLen + offsets in one array\n    let variableIdx = 0;\n    let fixedIdx = 0;\n    const fieldRanges = new Array(this.isFixedLen.length);\n    for (let i = 0; i < this.isFixedLen.length; i++) {\n      if (this.isFixedLen[i]) {\n        // push from fixLen ranges ++\n        fieldRanges[i] = this.fieldRangesFixedLen[fixedIdx++];\n      } else {\n        // push from varLen ranges ++\n        fieldRanges[i] = {\n          start: offsets[variableIdx],\n          end: offsets[variableIdx + 1]\n        };\n        variableIdx++;\n      }\n    }\n    return fieldRanges;\n  }\n}\nexports.ContainerType = ContainerType;\n/**\n * Returns the byte ranges of all variable size fields.\n */\nfunction readVariableOffsets(data, start, end, fixedEnd, variableOffsetsPosition) {\n  // Since variable-sized values can be interspersed with fixed-sized values, we precalculate\n  // the offset indices so we can more easily deserialize the fields in once pass first we get the fixed sizes\n  // Note: `fixedSizes[i] = null` if that field has variable length\n  const size = end - start;\n  // with the fixed sizes, we can read the offsets, and store for our single pass\n  const offsets = new Array(variableOffsetsPosition.length);\n  for (let i = 0; i < variableOffsetsPosition.length; i++) {\n    const offset = data.getUint32(start + variableOffsetsPosition[i], true);\n    // Validate offsets. If the list is empty the offset points to the end of the buffer, offset == size\n    if (offset > size) {\n      throw new Error(`Offset out of bounds ${offset} > ${size}`);\n    }\n    if (i === 0) {\n      if (offset !== fixedEnd) {\n        throw new Error(`First offset must equal to fixedEnd ${offset} != ${fixedEnd}`);\n      }\n    } else {\n      if (offset < offsets[i - 1]) {\n        throw new Error(`Offsets must be increasing ${offset} < ${offsets[i - 1]}`);\n      }\n    }\n    offsets[i] = offset;\n  }\n  return offsets;\n}\n/**\n * Precompute fixed and variable offsets position for faster deserialization.\n * @returns Does a single pass over all fields and returns:\n * - isFixedLen: If field index [i] is fixed length\n * - fieldRangesFixedLen: For fields with fixed length, their range of bytes\n * - variableOffsetsPosition: Position of the 4 bytes offset for variable size fields\n * - fixedEnd: End of the fixed size range\n * -\n */\nfunction precomputeSerdesData(fields) {\n  const isFixedLen = [];\n  const fieldRangesFixedLen = [];\n  const variableOffsetsPosition = [];\n  let pointerFixed = 0;\n  for (const fieldType of Object.values(fields)) {\n    isFixedLen.push(fieldType.fixedSize !== null);\n    if (fieldType.fixedSize === null) {\n      // Variable length\n      variableOffsetsPosition.push(pointerFixed);\n      pointerFixed += 4;\n    } else {\n      fieldRangesFixedLen.push({\n        start: pointerFixed,\n        end: pointerFixed + fieldType.fixedSize\n      });\n      pointerFixed += fieldType.fixedSize;\n    }\n  }\n  return {\n    isFixedLen,\n    fieldRangesFixedLen,\n    variableOffsetsPosition,\n    fixedEnd: pointerFixed\n  };\n}\n/**\n * Precompute sizes of the Container doing one pass over fields\n */\nfunction precomputeSizes(fields) {\n  let minLen = 0;\n  let maxLen = 0;\n  let fixedSize = 0;\n  for (const fieldType of Object.values(fields)) {\n    minLen += fieldType.minSize;\n    maxLen += fieldType.maxSize;\n    if (fieldType.fixedSize === null) {\n      // +4 for the offset\n      minLen += 4;\n      maxLen += 4;\n      fixedSize = null;\n    } else if (fixedSize !== null) {\n      fixedSize += fieldType.fixedSize;\n    }\n  }\n  return {\n    minLen,\n    maxLen,\n    fixedSize\n  };\n}\n/**\n * Compute the JSON key for each fieldName. There will exist a single JSON representation for each type.\n * To transform JSON payloads to a casing that is different from the type's defined use external tooling.\n */\nfunction precomputeJsonKey(fieldName, casingMap, jsonCase) {\n  if (casingMap) {\n    const keyFromCaseMap = casingMap[fieldName];\n    if (keyFromCaseMap === undefined) {\n      throw Error(`casingMap[${fieldName}] not defined`);\n    }\n    return keyFromCaseMap;\n  } else if (jsonCase) {\n    return strings_1.Case[jsonCase](fieldName);\n  } else {\n    return fieldName;\n  }\n}\nexports.precomputeJsonKey = precomputeJsonKey;\n/**\n * Render field typeNames for a detailed typeName of this Container\n */\nfunction renderContainerTypeName(fields) {\n  let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Container\";\n  const fieldNames = Object.keys(fields);\n  const fieldTypeNames = fieldNames.map(fieldName => `${fieldName}: ${fields[fieldName].typeName}`).join(\", \");\n  return `${prefix}({${fieldTypeNames}})`;\n}\nexports.renderContainerTypeName = renderContainerTypeName;","map":{"version":3,"names":["persistent_merkle_tree_1","require","merkleize_1","named_1","composite_1","container_1","container_2","strings_1","ContainerType","CompositeType","constructor","fields","opts","cachePermanentRootStruct","isList","isViewMutable","typeName","renderContainerTypeName","maxChunkCount","Object","keys","length","depth","maxChunksToDepth","fieldsEntries","fieldName","push","fieldType","jsonKey","precomputeJsonKey","casingMap","jsonCase","gindex","toGindex","BigInt","Error","fieldsGindex","i","jsonKeyToFieldName","minLen","maxLen","fixedSize","precomputeSizes","minSize","maxSize","isFixedLen","fieldRangesFixedLen","variableOffsetsPosition","fixedEnd","precomputeSerdesData","TreeView","getContainerTreeViewClass","TreeViewDU","getContainerTreeViewDUClass","named","namedClass","defaultValue","value","getView","tree","getViewDU","node","cache","cacheOfViewDU","view","commitView","commitViewDU","commit","value_serializedSize","totalSize","value_serializeToBytes","output","offset","fixedIndex","variableIndex","dataView","setUint32","value_deserializeFromBytes","data","start","end","fieldRanges","getFieldRanges","fieldRange","tree_serializedSize","nodes","getNodesAtDepth","tree_serializeToBytes","tree_deserializeFromBytes","Array","subtreeFillToContents","getRoots","struct","roots","hashTreeRoot","getPropertyGindex","prop","undefined","getPropertyType","type","getIndexProperty","index","tree_getLeafGindices","rootGindex","rootNode","gindices","fieldGindex","fieldGindexFromRoot","concatGindices","isBasic","compositeType","getNode","fromJson","json","jsonValue","toJson","clone","newValue","equals","a","b","size","offsets","readVariableOffsets","variableIdx","fixedIdx","exports","getUint32","pointerFixed","values","keyFromCaseMap","Case","prefix","arguments","fieldNames","fieldTypeNames","map","join"],"sources":["../../src/type/container.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}