{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BitListType = void 0;\nconst persistent_merkle_tree_1 = require(\"@chainsafe/persistent-merkle-tree\");\nconst merkleize_1 = require(\"../util/merkleize\");\nconst named_1 = require(\"../util/named\");\nconst arrayBasic_1 = require(\"./arrayBasic\");\nconst bitArray_1 = require(\"../value/bitArray\");\nconst bitArray_2 = require(\"./bitArray\");\n/**\n * BitList: ordered variable-length collection of boolean values, limited to N bits\n * - Notation `Bitlist[N]`\n * - Value: `BitArray`, @see BitArray for a justification of its memory efficiency and performance\n * - View: `BitArrayTreeView`\n * - ViewDU: `BitArrayTreeViewDU`\n */\nclass BitListType extends bitArray_2.BitArrayType {\n  constructor(limitBits, opts) {\n    super();\n    this.limitBits = limitBits;\n    this.fixedSize = null;\n    this.minSize = 1; // +1 for the extra padding bit\n    this.isList = true;\n    if (limitBits === 0) throw Error(\"List limit must be > 0\");\n    this.typeName = opts?.typeName ?? `BitList[${limitBits}]`;\n    // TODO Check that itemsPerChunk is an integer\n    this.maxChunkCount = Math.ceil(this.limitBits / 8 / 32);\n    this.chunkDepth = merkleize_1.maxChunksToDepth(this.maxChunkCount);\n    // Depth includes the extra level for the length node\n    this.depth = 1 + this.chunkDepth;\n    this.maxSize = Math.ceil(limitBits / 8) + 1; // +1 for the extra padding bit\n  }\n\n  static named(limitBits, opts) {\n    return new (named_1.namedClass(BitListType, opts.typeName))(limitBits, opts);\n  }\n  defaultValue() {\n    return bitArray_1.BitArray.fromBitLen(0);\n  }\n  // Views: inherited from BitArrayType\n  // Serialization + deserialization\n  value_serializedSize(value) {\n    return bitLenToSerializedLength(value.bitLen);\n  }\n  value_serializeToBytes(output, offset, value) {\n    output.uint8Array.set(value.uint8Array, offset);\n    return applyPaddingBit(output.uint8Array, offset, value.bitLen);\n  }\n  value_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    return new bitArray_1.BitArray(uint8Array, bitLen);\n  }\n  tree_serializedSize(node) {\n    return bitLenToSerializedLength(arrayBasic_1.getLengthFromRootNode(node));\n  }\n  tree_serializeToBytes(output, offset, node) {\n    const chunksNode = arrayBasic_1.getChunksNodeFromRootNode(node);\n    const bitLen = arrayBasic_1.getLengthFromRootNode(node);\n    const byteLen = Math.ceil(bitLen / 8);\n    const chunkLen = Math.ceil(byteLen / 32);\n    const nodes = persistent_merkle_tree_1.getNodesAtDepth(chunksNode, this.chunkDepth, 0, chunkLen);\n    persistent_merkle_tree_1.packedNodeRootsToBytes(output.dataView, offset, byteLen, nodes);\n    return applyPaddingBit(output.uint8Array, offset, bitLen);\n  }\n  tree_deserializeFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = this.deserializeUint8ArrayBitListFromBytes(data.uint8Array, start, end);\n    const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    const chunksNode = persistent_merkle_tree_1.packedRootsBytesToNode(this.chunkDepth, dataView, 0, uint8Array.length);\n    return arrayBasic_1.addLengthNode(chunksNode, bitLen);\n  }\n  tree_getByteLen(node) {\n    if (!node) throw new Error(\"BitListType requires a node to get leaves\");\n    return Math.ceil(arrayBasic_1.getLengthFromRootNode(node) / 8);\n  }\n  // Merkleization: inherited from BitArrayType\n  hashTreeRoot(value) {\n    return merkleize_1.mixInLength(super.hashTreeRoot(value), value.bitLen);\n  }\n  // Proofs: inherited from BitArrayType\n  // JSON: inherited from BitArrayType\n  // Deserializer helpers\n  deserializeUint8ArrayBitListFromBytes(data, start, end) {\n    const {\n      uint8Array,\n      bitLen\n    } = deserializeUint8ArrayBitListFromBytes(data, start, end);\n    if (bitLen > this.limitBits) {\n      throw Error(`bitLen over limit ${bitLen} > ${this.limitBits}`);\n    }\n    return {\n      uint8Array,\n      bitLen\n    };\n  }\n}\nexports.BitListType = BitListType;\nfunction deserializeUint8ArrayBitListFromBytes(data, start, end) {\n  if (end > data.length) {\n    throw Error(`BitList attempting to read byte ${end} of data length ${data.length}`);\n  }\n  const lastByte = data[end - 1];\n  const size = end - start;\n  if (lastByte === 0) {\n    throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n  }\n  if (lastByte === 1) {\n    // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n    const uint8Array = Uint8Array.prototype.slice.call(data, start, end - 1);\n    const bitLen = (size - 1) * 8;\n    return {\n      uint8Array,\n      bitLen\n    };\n  }\n  // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed\n  // Buffer.prototype.slice does not copy memory, Enforce Uint8Array usage https://github.com/nodejs/node/issues/28087\n  const uint8Array = Uint8Array.prototype.slice.call(data, start, end);\n  // mask lastChunkByte\n  const lastByteBitLength = lastByte.toString(2).length - 1;\n  const bitLen = (size - 1) * 8 + lastByteBitLength;\n  const mask = 0xff >> 8 - lastByteBitLength;\n  uint8Array[size - 1] &= mask;\n  return {\n    uint8Array,\n    bitLen\n  };\n}\nfunction bitLenToSerializedLength(bitLen) {\n  const bytes = Math.ceil(bitLen / 8);\n  // +1 for the extra padding bit\n  return bitLen % 8 === 0 ? bytes + 1 : bytes;\n}\n/**\n * Apply padding bit to a serialized BitList already written to `output` at `offset`\n * @returns New offset after (maybe) writting a padding bit.\n */\nfunction applyPaddingBit(output, offset, bitLen) {\n  const byteLen = Math.ceil(bitLen / 8);\n  const newOffset = offset + byteLen;\n  if (bitLen % 8 === 0) {\n    output[newOffset] = 1;\n    return newOffset + 1;\n  } else {\n    output[newOffset - 1] |= 1 << bitLen % 8;\n    return newOffset;\n  }\n}","map":{"version":3,"names":["persistent_merkle_tree_1","require","merkleize_1","named_1","arrayBasic_1","bitArray_1","bitArray_2","BitListType","BitArrayType","constructor","limitBits","opts","fixedSize","minSize","isList","Error","typeName","maxChunkCount","Math","ceil","chunkDepth","maxChunksToDepth","depth","maxSize","named","namedClass","defaultValue","BitArray","fromBitLen","value_serializedSize","value","bitLenToSerializedLength","bitLen","value_serializeToBytes","output","offset","uint8Array","set","applyPaddingBit","value_deserializeFromBytes","data","start","end","deserializeUint8ArrayBitListFromBytes","tree_serializedSize","node","getLengthFromRootNode","tree_serializeToBytes","chunksNode","getChunksNodeFromRootNode","byteLen","chunkLen","nodes","getNodesAtDepth","packedNodeRootsToBytes","dataView","tree_deserializeFromBytes","DataView","buffer","byteOffset","byteLength","packedRootsBytesToNode","length","addLengthNode","tree_getByteLen","hashTreeRoot","mixInLength","exports","lastByte","size","Uint8Array","prototype","slice","call","lastByteBitLength","toString","mask","bytes","newOffset"],"sources":["../../src/type/bitList.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}